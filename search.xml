<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>STM32学习（六）时钟源与时钟树</title>
      <link href="/2024/07/10/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%97%B6%E9%92%9F%E6%BA%90%E4%B8%8E%E6%97%B6%E9%92%9F%E6%A0%91/"/>
      <url>/2024/07/10/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%97%B6%E9%92%9F%E6%BA%90%E4%B8%8E%E6%97%B6%E9%92%9F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1>相关名词的简要介绍</h1><p>时钟源与时钟树的主体部分如下图所示：</p><p>内部时钟：由单片机内部决定；</p><p>外部时钟：由晶振决定；</p><p>PLL锁相环：提供一个倍频器的作用（作用之一）；</p><p>SYSCLK：系统时钟；</p><p>HCLK：AHB（先进高性能总线）的时钟线；</p><p>内存、内核、DMA：频率和HCLK保持一致；</p><p>APB1：USART2-5、SPI2-3、IIC、USB、CAN、通用定时器、基本定时器</p><p>APB2：USART1、SPI1、GPIO、ADC、高级定时器</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407102057211.png" alt="部分图"></p><p>FCLK：为中断采样提供信号，低功耗模式唤醒，在HCLK停止的情况下运行；</p><p>TO FLITFDCLK：flash编程接口的时钟，信号来源HSI；</p><p>TO USB：USB提供功能，来自PPL锁相环；</p><p>CSS：时钟安全系统，在HSE与PLCLK的情况下产生紧急制动，切换为HSI，保障时钟的稳定；</p><p>RTC和IWDG：实时时钟与看门狗，由LSI、LSE、和HSE的128分频输入；</p><p>MCO： cubemx中勾选相应的时钟输出功能，可以将时钟输出（不常用）。</p><p>总图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407102057367.png" alt="时钟源与时钟线总图"></p><h1>一些主要参考资料</h1><p>1.<a href="https://www.bilibili.com/video/BV1ph4y1e7Ey/?p=17&amp;spm_id_from=pageDriver">【STM32】超清晰STM32时钟树动画讲解_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32学习（五）IIC</title>
      <link href="/2024/07/06/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89IIC/"/>
      <url>/2024/07/06/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89IIC/</url>
      
        <content type="html"><![CDATA[<h1>一些前置知识</h1><h2 id="IIC的基本原理">IIC的基本原理</h2><p>IIC串行总线有两根信号线，一根是双向的<strong>数据线SDA</strong>，另一根是<strong>时钟线SCL。<strong>两条线都接上拉电阻，以确保</strong>总线空闲时刻为高电平</strong>，其中时钟信号是由主控器件产生。IIC总线支持多设备连接，允许多主机存在，对于并联在一条总线上的每个IIC设备都有唯一的地址**（即靠地址来区分每一个IIC设备）。**</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407101424310.png" alt="IIC"></p><h4 id="起始信号"><strong>起始信号</strong></h4><p>当时钟线（SCL）为高平时，数据线（SDA）从高电平跳变到低电平。</p><h4 id="终止信号"><strong>终止信号</strong></h4><p>当时钟线（SCL）为高平时，数据线（SDA）从低电平跳变到高电平。</p><h4 id="应答信号"><strong>应答信号</strong></h4><p>主机每发送一个字节（8个bit），就在<strong>第9个时钟脉冲期间释放数据线（SDA）</strong>，由从机反馈一个应答信号。</p><ul><li><p>应答信号**（SDA）为低电平**时，规定为有效应答位（ACK，简称应答位），表示从机成功地接收了该字节。</p></li><li><p>应答信号**（SDA）为高电平**时，规定为非应答位（NACK），一般表示从机接收该字节没有成功。</p></li></ul><h1>IIC的三种模式</h1><p>类似串口，iic同时也有相应的三种通信模式。</p><h2 id="轮询模式">轮询模式</h2><p>从上至下一次为速度模式（标准100000，快速400000），其余一般不动。</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407101706713.png" alt="轮询模式"></p><p>主要用到的HAL库代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Master_Receive(&amp;hic1,AHT20_ADDRESS,&amp;readBUffer,3,HAL_MAX_DELAY);  </span><br><span class="line">//接收函数，第一个是iic的地址指针，第二个是获取数据的地址，第三个为接收的数组地址，第四个是接收数据的长度，第五个是最长等待时间</span><br><span class="line"></span><br><span class="line">HAL_I2C_Master_Transmit(&amp;hic1,AHT20_ADDRESS,&amp;sendBUffer,3,HAL_MAX_DELAY);  </span><br><span class="line">//接收函数，第一个是iic的地址指针，第二个是将发送数据的地址，第三个为发送的数组地址，第四个是发送数据的长度，第五个是最长等待时间</span><br></pre></td></tr></table></figure><p>实践一：AHT20的读取串口发送</p><p>首先，移植相应的AHT20驱动，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line">  AHT20_Init();//初始化AHT20</span><br><span class="line">  float temperature = 0.0, humidity = 0.0;</span><br><span class="line">  char message[50];//定义相关的变量、数组名称</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">while (1) &#123;</span><br><span class="line">    AHT20_Measure();//读取AHT20</span><br><span class="line">    temperature = AHT20_Tempurature();</span><br><span class="line">    humidity = AHT20_Humidity();</span><br><span class="line">    sprintf(message, &quot;Temperature: %.2f, Humidity: %.2f%%\r\n&quot;, temperature, humidity);</span><br><span class="line">    //拼接字符串</span><br><span class="line">    HAL_UART_Transmit(&amp;huart2, (uint8_t *)message, strlen(message), HAL_MAX_DELAY);</span><br><span class="line">    HAL_Delay(1000);</span><br><span class="line">    /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">    /* USER CODE BEGIN 3 */</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="中断模式">中断模式</h2><h3 id="状态机的概念">状态机的概念</h3><p>在实际对一个模块的操作中，我们需要将其完成的工作模块化，这样方便我们对于它运行的状态进行判定。</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407101706193.png" alt="状态机"></p><h2 id="中断模式代码">中断模式代码</h2><p>开启中断模式</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407101539462.png" alt="中断模式"></p><p>所用到的HAL库函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)&#123;</span><br><span class="line">//接收完成中断</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)&#123;</span><br><span class="line">//发送完成中断</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HAL_I2C_Master_Receive_IT(&amp;hic1,AHT20_ADDRESS,&amp;readBUffer,3,HAL_MAX_DELAY);  </span><br><span class="line">//接收函数，第一个是iic的地址指针，第二个是获取数据的地址，第三个为接收的数组地址，第四个是接收数据的长度，第五个是最长等待时间</span><br><span class="line"></span><br><span class="line">HAL_I2C_Master_Transmit_IT(&amp;hic1,AHT20_ADDRESS,&amp;sendBUffer,3,HAL_MAX_DELAY);  </span><br><span class="line">//接收函数，第一个是iic的地址指针，第二个是将发送数据的地址，第三个为发送的数组地址，第四个是发送数据的长度，第五个是最长等待时间</span><br></pre></td></tr></table></figure><p>实践一：AHT20的读取串口发送</p><p>i2c.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* USER CODE BEGIN 0 */</span><br><span class="line"></span><br><span class="line">void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)&#123;</span><br><span class="line">   if(hi2c == &amp;hi2c1)&#123;</span><br><span class="line">   aht20_State == 2;</span><br><span class="line">&#125;//发送信息完成中断</span><br><span class="line"></span><br><span class="line">void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)&#123;</span><br><span class="line">   if(hi2c == &amp;hi2c1)&#123;</span><br><span class="line">   aht20_State == 4;</span><br><span class="line">&#125;//接收信息完成中断</span><br><span class="line"></span><br><span class="line">/* USER CODE END 0 */</span><br></pre></td></tr></table></figure><p>main.h</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN EC */</span><br><span class="line"></span><br><span class="line">extern uint8_t aht20_State;//提前变量，以便全局使用</span><br><span class="line"></span><br><span class="line">/* USER CODE END EC */</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>main.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">AHT20_Init();</span><br><span class="line">float temperature = 0.0, humidity = 0.0;</span><br><span class="line">char message[50];</span><br><span class="line"></span><br><span class="line">/* USER CODE END 2 */</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">while (1) &#123;</span><br><span class="line"></span><br><span class="line">if(aht20_State == 0)&#123;</span><br><span class="line">     AHT20_Measure();</span><br><span class="line">     aht20_State == 1;</span><br><span class="line">  &#125;else if(aht20_State == 2)&#123;</span><br><span class="line">     HAL_Delay(75);</span><br><span class="line">     AHT20_Get();</span><br><span class="line">     aht20_State == 3;</span><br><span class="line">  &#125;else if(aht20_State == 4)&#123;</span><br><span class="line">    AHT20_Analysis(&amp;temperature,&amp;humidity);</span><br><span class="line">    sprintf(message, &quot;Temperature: %.2f, Humidity: %.2f%%\r\n&quot;, temperature, humidity);</span><br><span class="line">    HAL_UART_Transmit(&amp;huart2, (uint8_t *)message, strlen(message), HAL_Delay(1000);</span><br><span class="line">    aht20_State == 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">  /* USER CODE BEGIN 3 */</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="DMA模式">DMA模式</h2><p>开启DMA模式</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407101539521.png" alt="DMA模式"></p><p>所用到的HAL库函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)&#123;</span><br><span class="line">//接收完成中断</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)&#123;</span><br><span class="line">//发送完成中断</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HAL_I2C_Master_Receive_DMA(&amp;hic1,AHT20_ADDRESS,&amp;readBUffer,3,HAL_MAX_DELAY);  </span><br><span class="line">//接收函数，第一个是iic的地址指针，第二个是获取数据的地址，第三个为接收的数组地址，第四个是接收数据的长度，第五个是最长等待时间</span><br><span class="line"></span><br><span class="line">HAL_I2C_Master_Transmit_DMA(&amp;hic1,AHT20_ADDRESS,&amp;sendBUffer,3,HAL_MAX_DELAY);  </span><br><span class="line">//接收函数，第一个是iic的地址指针，第二个是将发送数据的地址，第三个为发送的数组地址，第四个是发送数据的长度，第五个是最长等待时间</span><br></pre></td></tr></table></figure><p>代码实践</p><p>实践一：结合OLED和AHT20制作简易温湿度计</p><p>main.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> /* USER CODE BEGIN Includes */</span><br><span class="line">   #include &quot;oled.h&quot;</span><br><span class="line">   #include &quot;aht20.h&quot;</span><br><span class="line">   #include &quot;stdio.h&quot;</span><br><span class="line">   #include &quot;string.h&quot;</span><br><span class="line"> /* USER CODE END Includes */</span><br><span class="line"> </span><br><span class="line"> /* USER CODE BEGIN 2 */</span><br><span class="line">     HAL_Delay(20);</span><br><span class="line">     OLED_Init();</span><br><span class="line"> AHT20_Init();</span><br><span class="line">     float temperature = 0.0, humidity = 0.0;</span><br><span class="line"> char message[50];//初始化相应的的变量和函数</span><br><span class="line"> /* USER CODE END 2 */</span><br><span class="line"> </span><br><span class="line">while (1)</span><br><span class="line">  &#123;</span><br><span class="line">    /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">    /* USER CODE BEGIN 3 */</span><br><span class="line"> </span><br><span class="line">   AHT20_Measure();</span><br><span class="line">temperature=AHT20_Temperature();</span><br><span class="line">humidity=AHT20_Humidity();  </span><br><span class="line"></span><br><span class="line">    OLED_NewFrame();//准备新的图像</span><br><span class="line"></span><br><span class="line">OLED_DrawImage(15,0,&amp;temperatureImgImg,OLED_COLOR_NORMAL);</span><br><span class="line">//画图，x，y,图像指针，字符颜色</span><br><span class="line">sprintf(message,&quot;%.1f℃&quot;,temperature);//拼接字符串</span><br><span class="line">OLED_PrintString(45,15,message,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">//打印字符串，x，y,字符串指针地址，字符颜色</span><br><span class="line"></span><br><span class="line">OLED_DrawImage(15,30,&amp;humidityImgImg,OLED_COLOR_NORMAL);</span><br><span class="line">sprintf(message,&quot;%.1f%%&quot;,humidity);</span><br><span class="line">OLED_PrintString(45,40,message,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line"></span><br><span class="line">OLED_ShowFrame();//展示图像</span><br></pre></td></tr></table></figure><p>字体、图片需要用取模助手取模，放在font.c文件中，图片名称需要extern 提前变量在font.h中，以便全局调用。</p><h1>一些参考资料</h1><p>1.<a href="https://www.bilibili.com/video/BV1QN411D7ak/?spm_id_from=333.788&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">【STM32入门教程-2024】第12集 IIC通信与温湿度传感器AHT20(DHT20)_哔哩哔哩_bilibili</a></p><p>2.<a href="https://www.bilibili.com/video/BV1AN41127VL/?spm_id_from=333.788&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">【STM32入门教程-2024】第13集 IIC的中断与DMA以及状态机编程_哔哩哔哩_bilibili</a></p><p>3.<a href="https://www.bilibili.com/video/BV19u4y197df/?spm_id_from=333.788&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">【STM32入门教程-2024】第14集 如何在OLED屏幕上挥毫_哔哩哔哩_bilibili</a></p><p>4.<a href="https://www.bilibili.com/video/BV18u4y1e7PR/?spm_id_from=333.788&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">【STM32·番外】挑战5分钟制作温湿度计(A/DHT20+OLED)_哔哩哔哩_bilibili</a></p><p>5.<a href="https://blog.csdn.net/weixin_54076783/article/details/129597296?ops_request_misc=%7B%22request%5Fid%22%3A%22172049332416800197086902%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=172049332416800197086902&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-129597296-null-null.142%5Ev100%5Epc_search_result_base4&amp;utm_term=iicstm32&amp;spm=1018.2226.3001.4187">STM32之IIC_stm32 iic-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32学习（四）串口通信</title>
      <link href="/2024/07/02/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/"/>
      <url>/2024/07/02/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1>一些前置知识</h1><h2 id="并、串行通信的区别">并、串行通信的区别</h2><table><thead><tr><th style="text-align:left"></th><th>并行通信</th><th>串行通信</th></tr></thead><tbody><tr><td style="text-align:left">传输原理</td><td>数据各个位同时传输</td><td>数据按位顺序传输</td></tr><tr><td style="text-align:left">优点</td><td>速度快</td><td>占用引脚资源少</td></tr><tr><td style="text-align:left">缺点</td><td>占用引脚资源多</td><td>速度相对较慢</td></tr></tbody></table><h2 id="串行通信的分类">串行通信的分类</h2><p>（*）1、按照数据传送方向，分为：</p><p>单工：数据传输只支持数据在一个方向上传输；<br>半双工：允许数据在两个方向上传输。但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；它不需要独立的接收端和发送端，两者可以合并一起使用一个端口。<br>全双工：允许数据同时在两个方向上传输。因此，全双工通信是两个单工通信方式的结合，需要独立的接收端和发送端。</p><p>（***） 2、按照通信方式，分为：</p><p><strong>同步通信</strong>：带时钟同步信号传输。比如：SPI，IIC通信接口。<br><strong>异步通信</strong>：不带时钟同步信号。比如：UART(通用异步收发器)，单总线。<br>在同步通讯中，收发设备上方会使用一根信号线传输信号，在时钟信号的驱动下双方进行协调，同步数据。例如，通讯中通常双方会统一规定在时钟信号的上升沿或者下降沿对数据线进行采样。</p><p>在异步通讯中不使用时钟信号进行数据同步，它们直接在数据信号中穿插一些用于同步的信号位，或者将主题数据进行打包，以数据帧的格式传输数据。通讯中还需要双方规约好数据的传输速率（也就是波特率）等，以便更好地同步。常用的波特率有4800bps、9600bps、115200bps等。</p><p>在同步通讯中，数据信号所传输的内容绝大部分是有效数据，而异步通讯中会则会包含数据帧的各种标识符，所以同步通讯效率高，但是同步通讯双方的时钟允许误差小，稍稍时钟出错就可能导致数据错乱，异步通讯双方的时钟允许误差较大。</p><h1>三种串口通信方式</h1><h2 id="轮询方式">轮询方式</h2><p>特点：发一个，接受一个。</p><p>缺点：占用cpu，利用率较低。</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407032045432.png" alt="轮询模式"></p><p>波特率：常见的用115200，9600Bits/s。需要保证<strong>接收端和发送端波特率一致</strong>。</p><p>字节长度：8字节，外加前面1位起始位，后面1位结束位，一共10位。</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407032045638.png" alt="各种参数"></p><h2 id="轮询模式代码">轮询模式代码</h2><p>主要用到的hal库函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive(&amp;huart1,receveData,2,HAL_MAX_DELAY);</span><br><span class="line">//接收，第一位为串口地址，第二位为指针，第三位为数组长度，第四位为等待最大时长（HAL_MAX_DELAY为无限制时长）</span><br><span class="line"></span><br><span class="line">HAL_UART_Transmit(&amp;huart1,receveData,2,100);</span><br><span class="line">//发送，第一位为串口地址，第二位为指针，第三位为数组长度，第四位为等待最大时长（HAL_MAX_DELAY为无限制时长）</span><br></pre></td></tr></table></figure><h3 id="代码实践">代码实践</h3><p>通过轮询模式实现串口收发数据：</p><p>实践一：实现收发“Hello World”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">char message[]=&quot;Hello World&quot;</span><br><span class="line"></span><br><span class="line">  /* USER CODE END 2 */</span><br><span class="line"></span><br><span class="line">  /* Infinite loop */</span><br><span class="line">  /* USER CODE BEGIN WHILE */</span><br><span class="line">  while (1)</span><br><span class="line">  &#123;</span><br><span class="line">    /* USER CODE END WHILE */</span><br><span class="line">        </span><br><span class="line">        HAL_UART_Transmit(&amp;huart1,(uint8_t*)message,strlen(message),100);</span><br><span class="line">        //char强转为uint8_t类型</span><br><span class="line">        HAL_Delay(1000);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /* USER CODE BEGIN 3 */</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>实践二：实现发送对应信息，点亮对应小灯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">uint8_t  receveData[2];</span><br><span class="line"></span><br><span class="line">  /* USER CODE END 2 */</span><br><span class="line"></span><br><span class="line">  /* Infinite loop */</span><br><span class="line">  /* USER CODE BEGIN WHILE */</span><br><span class="line">  while (1)</span><br><span class="line">  &#123;</span><br><span class="line">    /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">HAL_UART_Receive(&amp;huart1,receveData,2,HAL_MAX_DELAY);</span><br><span class="line">HAL_UART_Transmit(&amp;huart1,receveData,2,100);</span><br><span class="line">if(receveData[1]==&#x27;1&#x27;&amp;&amp;receveData[0]==&#x27;R&#x27;)&#123;</span><br><span class="line">HAL_GPIO_TogglePin(LED_RED_GPIO_Port,LED_RED_Pin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(receveData[1]==&#x27;1&#x27;&amp;&amp;receveData[0]==&#x27;Y&#x27;)&#123;</span><br><span class="line">HAL_GPIO_WritePin(LED_YELLOW_GPIO_Port,LED_YELLOW_Pin,GPIO_PIN_SET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(receveData[1]==&#x27;1&#x27;&amp;&amp;receveData[0]==&#x27;G&#x27;)&#123;</span><br><span class="line">HAL_GPIO_WritePin(LED_GREEN_GPIO_Port,LED_GREEN_Pin,GPIO_PIN_SET);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">      //实现对传输信息的接收，并点亮对应的引脚</span><br><span class="line">    /* USER CODE BEGIN 3 */</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h2 id="中断模式">中断模式</h2><p>和轮询类似，只是CPU在寄存器空闲时可以处理其他事情。大致原理如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407032045666.png" alt="中断模式"></p><p>transmit发送和轮询一样，而receive接收，由于不会等待，所以在回调函数中书写相关的代码逻辑。</p><p>你需要在cubemx中开启全局中断。</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407032045273.png" alt="开启全局中断"></p><h2 id="中断模式代码">中断模式代码</h2><p>主要用到的hal库函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</span><br><span class="line">&#123; </span><br><span class="line">     //弱函数，中断回调函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  HAL_UART_Transmit_IT(&amp;huart1,receveData,2);//第一个为串口，第二个为指针，第三个为数组长度</span><br><span class="line"> </span><br><span class="line">  HAL_UART_Receive_IT(&amp;huart1,receveData,2);//第一个为串口，第二个为指针，第三个为数组长度</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="代码实践-2">代码实践</h3><p>实践一：与中断的实践二功能相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN PV */</span><br><span class="line">uint8_t  receveData[2];</span><br><span class="line">/* USER CODE END PV */</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/* USER CODE BEGIN 0 */</span><br><span class="line">void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)//在中断处理函数中书写代码逻辑</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">      HAL_UART_Transmit_IT(&amp;huart1,receveData,2);</span><br><span class="line">if(receveData[1]==&#x27;1&#x27;&amp;&amp;receveData[0]==&#x27;R&#x27;)&#123;</span><br><span class="line">HAL_GPIO_TogglePin(LED_RED_GPIO_Port,LED_RED_Pin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(receveData[1]==&#x27;1&#x27;&amp;&amp;receveData[0]==&#x27;Y&#x27;)&#123;</span><br><span class="line">HAL_GPIO_WritePin(LED_YELLOW_GPIO_Port,LED_YELLOW_Pin,GPIO_PIN_SET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(receveData[1]==&#x27;1&#x27;&amp;&amp;receveData[0]==&#x27;G&#x27;)&#123;</span><br><span class="line">HAL_GPIO_WritePin(LED_GREEN_GPIO_Port,LED_GREEN_Pin,GPIO_PIN_SET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HAL_UART_Receive_IT(&amp;huart1,receveData,2);//每次结束后，开启下一次的接收</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* USER CODE END 0 */</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/* USER CODE BEGIN 2 */</span><br><span class="line"></span><br><span class="line">HAL_UART_Receive_IT(&amp;huart1,receveData,2);//在main函数中开启接受的中断</span><br><span class="line"></span><br><span class="line"> /* USER CODE END 2 */</span><br></pre></td></tr></table></figure><h2 id="DMA模式">DMA模式</h2><p>搬运数据，创建通道，等待完成后通过中断处理函数通知cpu。</p><p>优点：进一步解放cpu。</p><p>开启DMA：（从左至右，从上至下，顺时针）开启的DMA通道，数据传输方向，优先级（一般默认），接收端和发送端是否地址自增，模式。</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407032046322.png" alt="DMA"></p><h2 id="DMA模式代码">DMA模式代码</h2><p>主要用到的hal库函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Transmit_DMA(&amp;huart1,receveData,2);//第一个为串口，第二个为指针，第三个为数组长度</span><br><span class="line"></span><br><span class="line">HAL_UART_Receive_DMA(&amp;huart1,receveData,2);//第一个为串口，第二个为指针，第三个为数组长度</span><br></pre></td></tr></table></figure><p>实践与上述两种方法类似，略。</p><h2 id="实现不定长数据接收">实现不定长数据接收</h2><p>主要用到的hal库函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__weak void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)</span><br><span class="line">//所用的中断回调函数</span><br><span class="line"></span><br><span class="line"> HAL_UARTEx_ReceiveToIdle(&amp;huart1,receveData,sizeof(receveData));</span><br><span class="line"> </span><br><span class="line"> HAL_UARTEx_ReceiveToIdle_IT(&amp;huart1,receveData,sizeof(receveData));</span><br><span class="line"> </span><br><span class="line"> HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1,receveData,sizeof(receveData));</span><br><span class="line"> //第三位是最大接收的长度，不大于数组长度</span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>此方式下DMA的缺点：传输过半中断会触发中断，即发送一半就会截断。</p><p>通过取消使能串口，取消中断。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern DMA_HandleTypeDef hdma_usart1_rx;</span><br><span class="line">//在main.h中进行定义（如果勾选了为每个外设生成单独的.c.h文件）</span><br><span class="line"></span><br><span class="line">__HAL_DMA_DISABLE_IT(&amp;hdma_usart1_rx,DMA_IT_HT);</span><br><span class="line">//第一个为dma的串口，在中断处理函数和main函数中都要添加</span><br></pre></td></tr></table></figure><h2 id="不定长数据接收代码">不定长数据接收代码</h2><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN PV */</span><br><span class="line"></span><br><span class="line">uint8_t  receveData[5];</span><br><span class="line"></span><br><span class="line">/* USER CODE END PV */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* USER CODE BEGIN 0 */</span><br><span class="line"></span><br><span class="line">void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if(huart==&amp;huart1)</span><br><span class="line">&#123;</span><br><span class="line">   HAL_UART_Transmit_DMA(&amp;huart1,receveData,Size);</span><br><span class="line">           HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1,receveData,sizeof(receveData));</span><br><span class="line">           //每次结束后都开启接收</span><br><span class="line">   __HAL_DMA_DISABLE_IT(&amp;hdma_usart1_rx,DMA_IT_HT);</span><br><span class="line">   //取消使能</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/* USER CODE END 0 */</span><br><span class="line">...</span><br><span class="line"> /* USER CODE BEGIN 2 */</span><br><span class="line"></span><br><span class="line">           HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1,receveData,sizeof(receveData));</span><br><span class="line">           //开启第一次接收</span><br><span class="line">          __HAL_DMA_DISABLE_IT(&amp;hdma_usart1_rx,DMA_IT_HT);//取消使能</span><br><span class="line"></span><br><span class="line">  /* USER CODE END 2 */</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>主要参考资源</h1><p>1.<a href="https://blog.csdn.net/u013407012/article/details/102465403?ops_request_misc=%7B%22request%5Fid%22%3A%22171997361916800188521398%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171997361916800188521398&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-102465403-null-null.142%5Ev100%5Epc_search_result_base4&amp;utm_term=%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1stm32&amp;spm=1018.2226.3001.4187">【STM32】串口通信基本原理（超基础、详细版）_stm32串口通信工作原理-CSDN博客</a></p><p>2.<a href="https://www.bilibili.com/video/BV1Na4y1T7VQ/?spm_id_from=333.788&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">【keysking的STM32教程】 第8集 STM32的串口通信_哔哩哔哩_bilibili</a></p><p>3.<a href="https://www.bilibili.com/video/BV1bc411J7Tv/?spm_id_from=333.788&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">【STM32入门教程-2024】第9集 STM32串口原理与串口中断模式收发 | keysking的stm32教程_哔哩哔哩_bilibili</a></p><p>4.<a href="https://www.bilibili.com/video/BV1do4y1F7wt/?spm_id_from=333.788&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">【工作STM32】第10集 STM32串口DMA模式与收发不定长数据 | keysking的stm32教程_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32学习（三）外部中断</title>
      <link href="/2024/05/01/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/"/>
      <url>/2024/05/01/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="一些前置知识">一些前置知识</h2><h3 id="内部原理简介">内部原理简介</h3><p>首先信号进入输入驱动器，详情见上一篇文章。</p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407021507259.png" alt="输入驱动器" style="zoom:80%;"><p>信号进入后顺序如下：</p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407021507544.png" alt="边路检测电路" style="zoom: 67%;"><p><strong>边路检测电路</strong>：信号进来首先经过上升下降选择寄存器，由CubeMx进行配置。第一个即为寄存器的配置。第二个为输入信号上拉下拉的配置。</p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407021507150.png" alt="上拉下拉处理中断" style="zoom: 33%;"><p>接着，经过一个或门。</p><p><strong>软件中断寄存器</strong>：模拟产生中断，用处可暂时忽略。</p><p><strong>事件屏蔽寄存器</strong>：非相关知识，之后了解。</p><p>输入后，</p><p><strong>请求挂起寄存器</strong>：相应位置变为’1’,即输入高电平信号。</p><p><strong>中断屏蔽寄存器</strong>：CubeMx已配置好。</p><p>经过与门，进入NVIC。</p><p>NVIC主要掌管中断向量表。主要由抢占优先级和响应优先级。主要规则如下：</p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407021507436.png" style="zoom: 33%;"><p>因此，如要在中断处理函数中使用HAL_DELAY，需要线配置“时钟滴答”的优先级，才可打断中断，实现延时。</p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407021507652.png" alt="设置优先级" style="zoom: 67%;"><h2 id="代码实践">代码实践</h2><h3 id="外部中断实现摁键控制亮灭">外部中断实现摁键控制亮灭</h3><p>在stm32f103xx_it.c中进行改写，如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void EXTI9_5_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">  /* USER CODE BEGIN EXTI9_5_IRQn 0 */</span><br><span class="line">  </span><br><span class="line">HAL_Delay(10);</span><br><span class="line">if(HAL_GPIO_ReadPin(KEY_GPIO_Port ,KEY_Pin)==GPIO_PIN_RESET)&#123;</span><br><span class="line">HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin);</span><br><span class="line">&#125;//实现摁键摁下，小灯翻转亮灭</span><br><span class="line"></span><br><span class="line">  /* USER CODE END EXTI9_5_IRQn 0 */</span><br><span class="line">  HAL_GPIO_EXTI_IRQHandler(KEY_Pin);</span><br><span class="line">  /* USER CODE BEGIN EXTI9_5_IRQn 1 */</span><br><span class="line"></span><br><span class="line">  /* USER CODE END EXTI9_5_IRQn 1 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些参考资源">一些参考资源</h2><p>1.【keysking的STM32教程】 第7集 深入讲解STM32中断_哔哩哔哩_bilibili</p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32学习（二）GPIO</title>
      <link href="/2024/04/06/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89GPIO/"/>
      <url>/2024/04/06/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89GPIO/</url>
      
        <content type="html"><![CDATA[<h2 id="一些前备知识">一些前备知识</h2><h3 id="两种MOS管">两种MOS管</h3><p>首先，在翻阅一些B站上的视频后，我发现大部分GPIO都讲到了其内部结构，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407021522441.png" alt="GPIO"></p><p>由于本人没学过模电数电，故不了解mos管，查阅后，了解后大致如下 ：</p><p>1.分为p mos和n mos，两种区别仅为底下的半导体不同，P型的是以p型为衬底，N型同理。n型半导体是硅掺5价磷，p掺3价硼。故前者带电子，后者有空穴。</p><p>2.n mos管实际上是由两个半导体组成，再加上一个栅格来控制导通（如果没有栅格，则无论正反向均导通不了），栅格通电，吸引电子，挤掉空穴，形成n沟道，导通。p型反之。箭头代表电子移动方向。如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407021522092.png" alt="两种MOS管"></p><p>3.n mos需要达到一定电压才可导通，p则需要小于一定电压。</p><h3 id="上拉电阻和下拉电阻">上拉电阻和下拉电阻</h3><p>1.设置上拉电阻，控制默认为高电压，当外部电路为低电压，产生数字信号，读取数据。</p><p>2.设置下拉电阻，控制默认为低电压，当外部电路为高电压，产生数字信号，读取数据。</p><h3 id="TTL肖特基触发器（施密特触发器）">TTL肖特基触发器（施密特触发器）</h3><p>设置阈值电压，消除电压的波动影响，将图形变化变为数字变化（01变化）。</p><h2 id="GPIO的八种模式">GPIO的八种模式</h2><p>（1）模拟输入:直接读取具体电压值，上拉下拉断开</p><p>（2）上拉输入：上拉电阻闭合</p><p>（3）下拉输入：下拉电阻闭合</p><p>（4）复用功能输入：一些外部模块的输出，如串口模块</p><p>（5）推挽输出：芯片自身提供电源</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407021522463.png" alt="推挽和开漏"></p><p>（6）开漏输出：外接提供电源</p><p>（7）复用推挽输出：外设模块，串口、iiic等</p><p>（8）复用开漏输出：同上</p><h2 id="GPIO相应的HAL库函数">GPIO相应的HAL库函数</h2><p>GPIO_Mode_AIN 模拟输入</p><p>GPIO_Mode_IN_FLOATING 浮空输入</p><p>GPIO_Mode_IPD 下拉输入</p><p>GPIO_Mode_IPU 上拉输入</p><p>GPIO_Mode_Out_OD 开漏输出</p><p>GPIO_Mode_Out_PP 推挽输出</p><p>GPIO_Mode_AF_OD 复用开漏输出</p><p>GPIO_Mode_AF_PP 复用推挽输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init);           #初始IO口状态      </span><br><span class="line"></span><br><span class="line">HAL_GPIO_DeInit(GPIO_TypeDef *GPIOx, uint32_t GPIO_Pin);                   #重置IO口状态 </span><br><span class="line"></span><br><span class="line">HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);                  #读取IO口状态 </span><br><span class="line"></span><br><span class="line">HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState);  #设置IO口状态 </span><br><span class="line"></span><br><span class="line">*PinState：GPIO 端口输出的状态，可以是 GPIO_PIN_RESET 或 GPIO_PIN_SET     </span><br><span class="line"></span><br><span class="line">HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);         #转换IO口状态      </span><br><span class="line"></span><br><span class="line">HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);                   #锁定IO口状态</span><br><span class="line"></span><br><span class="line">HAL_Delay()                                                                 #()填毫秒数</span><br></pre></td></tr></table></figure><h2 id="实践led点亮-有源蜂鸣器的发音">实践led点亮/有源蜂鸣器的发音</h2><p>Cubemx对应引脚设置GPIO_Output,生成代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">while (1)</span><br><span class="line"> &#123;</span><br><span class="line">   /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">   /* USER CODE BEGIN 3 */</span><br><span class="line"></span><br><span class="line">     HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState);  #填入你的IO口及对应状态</span><br><span class="line">     HAL_Delay(500);</span><br><span class="line">     HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState);  #填入你的IO口及对应相反状态</span><br><span class="line">     HAL_Delay(500);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>或者，你可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while (1)</span><br><span class="line"> &#123;</span><br><span class="line">   /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">   /* USER CODE BEGIN 3 */</span><br><span class="line"></span><br><span class="line">    HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);           #填入你的IO口及对应状态</span><br><span class="line">     HAL_Delay(500);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>则可以实现led的闪烁和蜂鸣器的发音。</p><h2 id="摁键的控制-光敏传感器的传感">摁键的控制/光敏传感器的传感</h2><p>Cubemx对应引脚设置GPIO_INput,生成代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">while (1)</span><br><span class="line"> &#123;</span><br><span class="line">   /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">   /* USER CODE BEGIN 3 */</span><br><span class="line">   </span><br><span class="line">    HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);           #填入你的IO口</span><br><span class="line">    </span><br><span class="line">    if(HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)==GPIO_PIN_RESET)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">       HAL_Delay(10);   #延时消抖     </span><br><span class="line">       </span><br><span class="line">         if(HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)==GPIO_PIN_RESET)  #简单的摁键消抖</span><br><span class="line">          &#123;</span><br><span class="line">            #摁键/光敏传感器所控制的模块</span><br><span class="line">          &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">光敏模块引脚说明</span><br><span class="line"></span><br><span class="line">VCC：电源引脚，接单片机+5V或者3.3V。</span><br><span class="line">GND：地线，接单片机GND。</span><br><span class="line">DO：开关量输出（0或1），模块在无光条件下或光强达不到设定阈值时，DO口输出高电平；当外界环境光强超过设定阈值时，DO输出低电平。</span><br><span class="line">AO：模拟量输出（电压），与单片机AD模块相连，通过AD转换，获得准确数值。（后续中使用PA1引脚作为ADC转换，因此此处接单片机的PA1引脚）</span><br></pre></td></tr></table></figure><p>故只能实现光信号简单的控制。</p><h2 id="主要参考资源">主要参考资源</h2><p>1.<a href="https://www.bilibili.com/video/BV1th411z7sn?p=8&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">B站江科大stm32  P5-8</a></p><p>2.<a href="https://www.bilibili.com/video/BV1mU421o7vt/?spm_id_from=333.337.search-card.all.click&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">B站keysking</a></p><p>3.<a href="https://www.bilibili.com/video/BV1344y167qm?spm_id_from=333.880.my_history.page.click">B站爱上半导体</a></p><p>4.<a href="https://www.bilibili.com/video/BV1bt4y177E8?spm_id_from=333.880.my_history.page.click">维库电子市场网</a></p><p>5.<a href="https://blog.csdn.net/weixin_58632615/article/details/124729997?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=stm32hal%E5%BA%93%E5%85%89%E6%95%8F&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduweb~default-6-124729997.nonecase&amp;spm=1018.2226.3001.4450">CSDN xiang–ying</a></p><p>6.<a href="https://blog.csdn.net/qq_41968464/article/details/126856223?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171240583816800222891676%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171240583816800222891676&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-126856223-null-null.142%5Ev100%5Epc_search_result_base4&amp;utm_term=stm32hal%E5%BA%93%E5%85%89%E6%95%8F&amp;spm=1018.2226.3001.4187">CSDN 编号09527</a></p><p>7.stm32官方固件参考手册 、stm32中文参考手册</p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32学习（一）序言</title>
      <link href="/2024/04/05/stm32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%BA%8F%E8%A8%80/"/>
      <url>/2024/04/05/stm32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%BA%8F%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="学习stm32的初衷">学习stm32的初衷</h2><p>由于我参加了足基的春招，铩羽而归，发现之前所学不成体系，故以写博客的方式来梳理知识，希望可以在stm32上有些许收获。</p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
