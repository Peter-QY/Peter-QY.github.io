<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ROS学习（一）话题通信</title>
      <link href="/2025/08/30/ROS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/"/>
      <url>/2025/08/30/ROS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1>话题通信的意义</h1><p>为了获取周围的信息（传感器、相关数据），ROS2引入了专门的订阅发布机制，是ROS中最常用的通信方式之一。</p><h1>在命令行里发布话题</h1><p>此处以小海龟模拟器为例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ros2 node info /turtlesim <span class="comment">#用于查看节点的详细信息 </span></span><br><span class="line"><span class="comment">#Subscribers:其订阅的所有话题；</span></span><br><span class="line"><span class="comment">#Publishers：节点发布的所有话题 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic echo /turtle1/pose<span class="comment">#用于输出话题数据的命令</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic info /turtle1/cmd_vel -v<span class="comment">#用于查看某个话题的具体信息</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 interface show geometry_msgs/msg/Twist<span class="comment">#用于输出接口的定义内容</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic pub /turtle1/cmd_vel geometry_msgs/msg/Twist <span class="string">&quot;&#123;linear: &#123;x: 1.0&#125;&#125;&quot;</span></span><br><span class="line"><span class="comment">#以线速度1.0m/s向右直行</span></span><br></pre></td></tr></table></figure><h1>使用Python发布与订阅话题</h1><h2 id="使用Python发布话题">使用Python发布话题</h2><p>新建一个文件夹，vscode打开，然后该文件夹下创建topic_ws，在下面创建src目录，打开终端，创建demo_python_topic功能包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create demo_python_topic --build-<span class="built_in">type</span> ament_python --dependencies rclpy example_interfaces --license Apache-<span class="number">2.0</span></span><br><span class="line"><span class="comment">#创建demo_python_topic功能包</span></span><br></pre></td></tr></table></figure><p>创建novel_pub_node.py文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> rclpy</span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node </span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> example_interfaces.msg <span class="keyword">import</span> String</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NovelPubNode</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,node_name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(node_name)</span><br><span class="line">        self.novels_queue_=Queue()<span class="comment">#创建队列，存放小说</span></span><br><span class="line">        self.novel_publisher_=self.create_publisher(String,<span class="string">&#x27;novel&#x27;</span>,<span class="number">10</span>)</span><br><span class="line">        <span class="comment">#创建话题发布者，发布小说</span></span><br><span class="line">        self.timer_=self.create_timer(<span class="number">5</span>,self.timer_callback)<span class="comment">#创建定时器</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">download_novel</span>(<span class="params">self,url</span>):</span><br><span class="line">        response =requests.get(url)</span><br><span class="line">        response.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">        self.get_logger().info(<span class="string">f&#x27;下载完成:<span class="subst">&#123;url&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> response.text.splitlines():</span><br><span class="line">            self.novels_queue_.put(line)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">timer_callback</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.novels_queue_.qsize() &gt;<span class="number">0</span> : </span><br><span class="line">            msg = String()<span class="comment">#实例化一个信息p[p]</span></span><br><span class="line">            msg.data = self.novels_queue_.get()<span class="comment">#</span></span><br><span class="line">            self.novel_publisher_.publish(msg)</span><br><span class="line">            self.get_logger().info(<span class="string">f&#x27;发布了一行小说：<span class="subst">&#123;msg.data&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    rclpy.init()</span><br><span class="line">    node =NovelPubNode(<span class="string">&#x27;novel_pub&#x27;</span>)</span><br><span class="line">    node.download_novel(<span class="string">&#x27;http://localhost:8000/novel1.txt&#x27;</span>)</span><br><span class="line">    rclpy.spin(node)</span><br><span class="line">    rclpy.shutdown()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在setup.py中添加启动语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#...</span></span><br><span class="line">entry_points=&#123;</span><br><span class="line">     <span class="string">&#x27;console_scripts&#x27;</span>: [</span><br><span class="line">         <span class="string">&#x27;novel_pub_node = demo_python_topic.novel_pub_node:main&#x27;</span>,</span><br><span class="line">     ],</span><br><span class="line">    <span class="comment">#在这里添加构建语句</span></span><br></pre></td></tr></table></figure><p>新建一个终端（相当于一个是发布者，一个是订阅者）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server <span class="number">8000</span><span class="comment">#打开http</span></span><br></pre></td></tr></table></figure><p>编译，运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">colcon build<span class="comment">#编译</span></span><br><span class="line">source install/setup.bash</span><br><span class="line">ros2 run demo_python_topic novel_pub_node<span class="comment">#运行程序</span></span><br></pre></td></tr></table></figure><p>然后就可以下载src目录下构建的novel1.txt文件里的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[INFO] [1756389267.525765835] [novel_pub]: 下载完成:http://localhost:8000/novel1.txt</span><br><span class="line">[INFO] [1756389272.173843085] [novel_pub]: 发布了一行小说：这是一个美丽的故事开始。</span><br><span class="line">[INFO] [1756389277.174012442] [novel_pub]: 发布了一行小说：主人公踏上了冒险的旅程。</span><br><span class="line">[INFO] [1756389282.181176548] [novel_pub]: 发布了一行小说：他遇到了许多有趣的人物。</span><br><span class="line">8[INFO] [1756389287.174946628] [novel_pub]: 发布了一行小说：每个章节都充满了惊喜和挑战。</span><br><span class="line">[INFO] [1756389292.173441667] [novel_pub]: 发布了一行小说：故事逐渐展开，情节越来越精彩。</span><br></pre></td></tr></table></figure><h2 id="使用Python订阅话题">使用Python订阅话题</h2><p>创建novel_pub_node.py文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> espeakng</span><br><span class="line"><span class="keyword">import</span> rclpy</span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node </span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> example_interfaces.msg <span class="keyword">import</span> String</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NovelSubNode</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,node_name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(node_name)</span><br><span class="line">        self.novels_queue_=Queue()<span class="comment">#创建队列，存放小说</span></span><br><span class="line">        self.novel_subscriber_=self.create_subscription(String,<span class="string">&#x27;novel&#x27;</span>,self.novel_callback,<span class="number">10</span>)</span><br><span class="line">        self.speech_thread_ =threading.Thread(target=self.speak_thread)</span><br><span class="line">        self.speech_thread_.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">novel_callback</span>(<span class="params">self,msg</span>):</span><br><span class="line">        self.novels_queue_.put(msg.data)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak_thread</span>(<span class="params">self</span>):</span><br><span class="line">        speaker = espeakng.Speaker()</span><br><span class="line">        speaker.voice = <span class="string">&#x27;zh&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> rclpy.ok():</span><br><span class="line">            <span class="keyword">if</span> self.novels_queue_.qsize()&gt;<span class="number">0</span>:</span><br><span class="line">                text = self.novels_queue_.get()</span><br><span class="line">                self.get_logger().info(<span class="string">f&#x27;正在朗读：<span class="subst">&#123;text&#125;</span>&#x27;</span>)</span><br><span class="line">                speaker.say(text)</span><br><span class="line">                speaker.wait()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args=<span class="literal">None</span></span>):</span><br><span class="line">    rclpy.init(args=args)</span><br><span class="line">    node =NovelSubNode(<span class="string">&#x27;novel_read&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    rclpy.spin(node)</span><br><span class="line">    rclpy.shutdown()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在setup.py中添加启动语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#...</span></span><br><span class="line">entry_points=&#123;</span><br><span class="line">     <span class="string">&#x27;console_scripts&#x27;</span>: [</span><br><span class="line">         <span class="string">&#x27;novel_pub_node = demo_python_topic.novel_pub_node:main&#x27;</span>,\</span><br><span class="line">         <span class="string">&#x27;novel_sub_node = demo_python_topic.novel_sub_node:main&#x27;</span>,</span><br><span class="line">     ],</span><br><span class="line">    <span class="comment">#在这里添加构建语句</span></span><br></pre></td></tr></table></figure><p>查看发布者和接收者的命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic <span class="built_in">list</span> -v</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Published topics:</span><br><span class="line"> * /novel [example_interfaces/msg/String] 1 publisher</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Subscribed topics:</span><br><span class="line"> * /novel [example_interfaces/msg/String] 1 subscriber</span><br></pre></td></tr></table></figure><p>至此，已经完成python的所有的发布与订阅流程。</p><h2 id="可参考其他文章：">可参考其他文章：</h2><p><a href="https://zhuanlan.zhihu.com/p/23645180597">(20 封私信 / 80 条消息) ROS2之第2讲–话题（topic）程序的编写 - 知乎</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32学习（七）定时器</title>
      <link href="/2024/07/11/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
      <url>/2024/07/11/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1>基本定时器</h1><p>定时器就是计数器。以下是基本定时器的内容和相关HAL库函数</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407142226562.png" alt="普通模式"></p><h1>代码实践一</h1><p>实践一：定时器实现定时发送数据</p><p>配置界面如下：</p><p>**（1）**Prescaler：对于分频器的设置</p><p>​          Counter Period：对于自动重装载寄存器的值，计数周期，用于计算时间周期</p><p>​          auto-reload preload：自动重装载的影子寄存器</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407142226332.png" alt="普通模式配置1"></p><p>**（2）**开启串口</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407142226238.png" alt="普通模式配置2"></p><p>**（3）**开启串口</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407142226250.png" alt="普通模式配置3"></p><p>所用的HAL库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_Base_Start_IT(&amp;htim4);//中断模式开启定时器（-IT）</span><br><span class="line"></span><br><span class="line">void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)</span><br><span class="line">//定时器更新中断函数，在到达设定的数值时，启动该函数，重新计数</span><br><span class="line"></span><br><span class="line">__HAL_TIM_GetCounter(&amp;htim4)//用一个变量获取定时器的数据</span><br></pre></td></tr></table></figure><p>函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">/* USER CODE BEGIN Includes */</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;//包含相应的头文件</span><br><span class="line">/* USER CODE END Includes */</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/* USER CODE BEGIN PFP */</span><br><span class="line">  char date[]=&quot;😊😊😊😊&quot;;</span><br><span class="line">/* USER CODE END PFP */</span><br><span class="line"></span><br><span class="line">/* Private user code ---------------------------------------------------------*/</span><br><span class="line">/* USER CODE BEGIN 0 */</span><br><span class="line">void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)&#123;</span><br><span class="line">  if(htim==&amp;htim4)//判断一下可以判断相关的</span><br><span class="line">  &#123;</span><br><span class="line">HAL_UART_Transmit_IT(&amp;huart1,(uint8_t*)date,strlen(date));//串口发送相关的数据</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/* USER CODE END 0 */</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"> /* USER CODE BEGIN 2 */</span><br><span class="line">    HAL_TIM_Base_Start_IT(&amp;htim4);//启动相关的定时器的口子</span><br><span class="line">    int counter = 0;</span><br><span class="line">    char message[20];</span><br><span class="line">  /* USER CODE END 2 */</span><br><span class="line"></span><br><span class="line">  /* Infinite loop */</span><br><span class="line">  /* USER CODE BEGIN WHILE */</span><br><span class="line">  while (1)</span><br><span class="line">  &#123;</span><br><span class="line">counter =__HAL_TIM_GetCounter(&amp;htim4);</span><br><span class="line">sprintf(message,&quot;counter: %d&quot;,counter);//拼接字符串</span><br><span class="line">HAL_Delay(99);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">    /* USER CODE BEGIN 3 */</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h1>通用/高级定时器</h1><p>通用、高级定时器有四个输入通道：</p><p><strong>TI1-4</strong>：只有1和2接入触发器，TI1FP1、TI2FP2可以选择上、下、双边沿触发，TI1_ED只能双边沿检测。</p><p>通过外部时钟1进入从模式控制器</p><p><strong>ETR</strong>：极性选择：上升沿还是下降沿</p><p>边沿检测：只能实现一种检测</p><p>预分频：降低输入的速度</p><p>输入滤波：滤去不必要的干扰</p><p>可以通过触发器进入从模式控制器，也可以直接进入触发控制器。</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407142226103.png" alt="通用&amp;高级模式"></p><h1>代码实践二</h1><p>实践一：实现红外发射模块实现计数黑白条纹在OLED上显示</p><p>配置界面如下：</p><p>（1）选择“外部时钟1”</p><p>触发模式可以选择TI1FP1、TI2FP2、TI1_ED，由于精确计数，所以选择不分频</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407142226531.png" alt="通用模式配置1"></p><p>（2）</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407142226137.png" alt="通用模式配置2"></p><p>所用到的HAL库函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_Base_Start(&amp;htim2);//阻塞模式下的定时器开启模式</span><br><span class="line"></span><br><span class="line">__HAL_TIM_GetCounter(&amp;htim4)//用一个变量获取定时器的数据</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">/* USER CODE BEGIN Includes */</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">#include  &quot;oled.h&quot;</span><br><span class="line">/* USER CODE END Includes */</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  /* USER CODE BEGIN 2 */</span><br><span class="line">         HAL_Delay(20);</span><br><span class="line">         OLED_Init();</span><br><span class="line"> HAL_TIM_Base_Start(&amp;htim2);</span><br><span class="line"> int counter=0;</span><br><span class="line"> char message[20]=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">  /* USER CODE END 2 */</span><br><span class="line">  </span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line">  /* USER CODE BEGIN WHILE */</span><br><span class="line">  while (1)</span><br><span class="line">  &#123;</span><br><span class="line">    OLED_NewFrame();</span><br><span class="line">counter=__HAL_TIM_GET_COUNTER(&amp;htim2);</span><br><span class="line">sprintf(message,&quot;counter:%d&quot;,counter);</span><br><span class="line">OLED_PrintString(10,10,message,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">    /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">    /* USER CODE BEGIN 3 */</span><br><span class="line">  &#125;</span><br><span class="line">  /* USER CODE END 3 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1>定时器从模式</h1><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407142227796.png" alt="三种模式"></p><h2 id="复位模式">复位模式</h2><p>实践1：红外检测计数，每5秒自动重装载，或是外部触发，进行串口发送数据。</p><p>复位模式下，在正常计数的情况下，接收到触发信号就会中断，进行更新实践，同样会触发更新中断。（如果开启中断的情况下）</p><p>配置如下：由内部时钟提供计时（之前所说ETR的外部时钟2的作用与之类似，只不过一个内部时钟，一个外部时钟）（One  Pulse Mode不用勾选）；开启相应的串口。</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407142227135.png" alt="复位模式配置"></p><p>所用到的HAL库函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__HAL_TIM_GET_FLAG(htim,TIM_FLAG_TRIGGER)</span><br><span class="line">//获取标志位，第一位是定时器操作句柄的指针，第二个是获取操作位的值</span><br><span class="line"></span><br><span class="line">__HAL_TIM_CLEAR_FLAG(htim,TIM_FLAG_TRIGGER);</span><br><span class="line">//清理标志位，第一位是定时器操作句柄的指针，第二个是获取操作位的值</span><br><span class="line"></span><br><span class="line">void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)</span><br><span class="line">//中断更新函数</span><br><span class="line"></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line">//开启定时器中断</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN 0 */</span><br><span class="line">char update[]=&quot;自动重装载&quot;;</span><br><span class="line">char trigger[]=&quot;从模式触发&quot;;</span><br><span class="line">void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)&#123;</span><br><span class="line">if(htim==&amp;htim2)</span><br><span class="line">&#123;</span><br><span class="line">if(__HAL_TIM_GET_FLAG(htim,TIM_FLAG_TRIGGER)==SET)&#123;</span><br><span class="line">__HAL_TIM_CLEAR_FLAG(htim,TIM_FLAG_TRIGGER);</span><br><span class="line">    HAL_UART_Transmit(&amp;huart1,(uint8_t*)trigger,strlen(trigger),100);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">HAL_UART_Transmit(&amp;huart1,(uint8_t*)update,strlen(update),100);</span><br><span class="line">&#125;//判断相应的标志位，并改变不同的标志位数值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* USER CODE END 0 */</span><br><span class="line"></span><br><span class="line">  /* USER CODE BEGIN 2 */</span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim2);//开启定时器中断（非阻塞模式）</span><br><span class="line">int counter =0;</span><br><span class="line">char message[] =&quot;&quot;;</span><br><span class="line">  /* USER CODE END 2 */</span><br><span class="line"></span><br><span class="line">  /* Infinite loop */</span><br><span class="line">  /* USER CODE BEGIN WHILE */</span><br><span class="line">  while (1)</span><br><span class="line">  &#123;</span><br><span class="line">counter=__HAL_TIM_GET_COUNTER(&amp;htim2);//获取数据</span><br><span class="line">sprintf(message,&quot;counter:%d&quot;,counter);</span><br><span class="line">    HAL_UART_Transmit(&amp;huart1,(uint8_t*)message,strlen(message),100);</span><br><span class="line">        HAL_Delay(500);</span><br><span class="line">    /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">    /* USER CODE BEGIN 3 */</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="门模式">门模式</h2><p>实践1：红外检测计数，每5秒自动重装载，或是外部触发，进行串口发送数据。</p><p>门模式下，下降的时候暂停计时，上升时继续计数，实现计数暂停、继续的控制。</p><p>配置如下：由内部时钟提供计时，One  Pulse Mode不用勾选；开启相应的串口。</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407142227437.png" alt="门模式配置"></p><p>所用到的HAL库函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__HAL_TIM_GET_FLAG(htim,TIM_FLAG_TRIGGER)</span><br><span class="line">//获取标志位，第一位是定时器操作句柄的指针，第二个是获取操作位的值</span><br><span class="line"></span><br><span class="line">__HAL_TIM_CLEAR_FLAG(htim,TIM_FLAG_TRIGGER);</span><br><span class="line">//清理标志位，第一位是定时器操作句柄的指针，第二个是获取操作位的值</span><br><span class="line"></span><br><span class="line">void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)</span><br><span class="line">//中断更新函数</span><br><span class="line"></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line">//开启定时器中断</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN 0 */</span><br><span class="line">char update[]=&quot;自动重装载&quot;;</span><br><span class="line">char trigger[]=&quot;从模式触发&quot;;</span><br><span class="line">void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)&#123;</span><br><span class="line">if(htim==&amp;htim2)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">HAL_UART_Transmit(&amp;huart1,(uint8_t*)update,strlen(update),100);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//触发更新中断，在定时器更新中断中传输相应的数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* USER CODE END 0 */</span><br><span class="line"></span><br><span class="line">  /* USER CODE BEGIN 2 */</span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim2);//开启定时器中断（非阻塞模式）</span><br><span class="line">int counter =0;</span><br><span class="line">char message[] =&quot;&quot;;</span><br><span class="line">  /* USER CODE END 2 */</span><br><span class="line"></span><br><span class="line">  /* Infinite loop */</span><br><span class="line">  /* USER CODE BEGIN WHILE */</span><br><span class="line">  while (1) </span><br><span class="line">  &#123;    </span><br><span class="line">       if(__HAL_TIM_GET_FLAG(htim,TIM_FLAG_TRIGGER)==SET)&#123;</span><br><span class="line">       __HAL_TIM_CLEAR_FLAG(htim,TIM_FLAG_TRIGGER);</span><br><span class="line">           HAL_UART_Transmit(&amp;huart1,(uint8_t*)trigger,strlen(trigger),100);</span><br><span class="line">     &#125;//门模式下不再开启定时器更新中断，所以将判断触发的逻辑写在主函数中，以便清零标志位</span><br><span class="line">     </span><br><span class="line">counter=__HAL_TIM_GET_COUNTER(&amp;htim2);//获取数据</span><br><span class="line">sprintf(message,&quot;counter:%d&quot;,counter);</span><br><span class="line">    HAL_UART_Transmit(&amp;huart1,(uint8_t*)message,strlen(message),100);</span><br><span class="line">        HAL_Delay(500);</span><br><span class="line">    /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">    /* USER CODE BEGIN 3 */</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="触发模式">触发模式</h2><p>实践1：红外检测计数，外部触发开始计数，配合单脉冲模式，实现一个计数周期，进行串口发送数据。</p><p>触发模式下，只能启动定时器，而不能停止定时器，可以配合单脉冲模式（One  Pulse Mode）使用，在达到设定的数据时，停止计数。</p><p>配置如下：由内部时钟提供计时；开启相应的串口。</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407142227381.png" alt="触发模式配置"></p><p>所用的HAL库函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__HAL_TIM_GET_FLAG(htim,TIM_FLAG_TRIGGER)</span><br><span class="line">//获取标志位，第一位是定时器操作句柄的指针，第二个是获取操作位的值</span><br><span class="line"></span><br><span class="line">__HAL_TIM_CLEAR_FLAG(htim,TIM_FLAG_TRIGGER);</span><br><span class="line">//清理标志位，第一位是定时器操作句柄的指针，第二个是获取操作位的值</span><br><span class="line"></span><br><span class="line">void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)</span><br><span class="line">//中断更新函数</span><br><span class="line"></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line">//开启定时器中断</span><br></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN 0 */</span><br><span class="line">char update[]=&quot;自动重装载&quot;;</span><br><span class="line">char trigger[]=&quot;从模式触发&quot;;</span><br><span class="line">void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)&#123;</span><br><span class="line">if(htim==&amp;htim2)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">HAL_UART_Transmit(&amp;huart1,(uint8_t*)update,strlen(update),100);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//触发更新中断，在定时器更新中断中传输相应的数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* USER CODE END 0 */</span><br><span class="line"></span><br><span class="line">  /* USER CODE BEGIN 2 */</span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim2);//开启定时器中断（非阻塞模式）</span><br><span class="line">int counter =0;</span><br><span class="line">char message[] =&quot;&quot;;</span><br><span class="line">  /* USER CODE END 2 */</span><br><span class="line"></span><br><span class="line">  /* Infinite loop */</span><br><span class="line">  /* USER CODE BEGIN WHILE */</span><br><span class="line">  while (1) </span><br><span class="line">  &#123;    </span><br><span class="line">       if(__HAL_TIM_GET_FLAG(htim,TIM_FLAG_TRIGGER)==SET)&#123;</span><br><span class="line">       __HAL_TIM_CLEAR_FLAG(htim,TIM_FLAG_TRIGGER);</span><br><span class="line">           HAL_UART_Transmit(&amp;huart1,(uint8_t*)trigger,strlen(trigger),100);</span><br><span class="line">     &#125;//门模式下不再开启定时器更新中断，所以将判断触发的逻辑写在主函数中，以便清零标志位</span><br><span class="line">     </span><br><span class="line">counter=__HAL_TIM_GET_COUNTER(&amp;htim2);//获取数据</span><br><span class="line">sprintf(message,&quot;counter:%d&quot;,counter);</span><br><span class="line">    HAL_UART_Transmit(&amp;huart1,(uint8_t*)message,strlen(message),100);</span><br><span class="line">        HAL_Delay(500);</span><br><span class="line">    /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">    /* USER CODE BEGIN 3 */</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="一个小知识">一个小知识</h2><p><strong>程序刚启动/复位时，会输出“自动重装载”？</strong><br><strong>原因</strong>：  MX_TIM2_Init();将标志位置为1，</p><p>​              HAL_TIM_Base_Start_IT(&amp;htim2);开启中断</p><p>​              NVIC检测到，因此输出“自动重装载”</p><p><strong>解决办法</strong>：将HAL_TIM_CLEAR_FLAG(&amp;htim2,TIM_FLAG_UPDATE);</p><p>​                 或者HAL_TIM_CLEAR_IT(&amp;htim2,TIM_FLAG_UPDATE);</p><p>​                 放在HAL_TIM_Base_Start_IT(&amp;htim2);前即可。</p><h1>输入捕获</h1><p>同一个信号通过两种不同通道，实现对上升沿与下降沿的间距测量，即一个设为直接输入，一个输入为间接捕获，TI1和TI2、TI3和TI4为一对</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407142227326.png" alt="输入捕获"></p><h1>代码实践三</h1><p>实践1：超声波模块实现测距，并显示在OLED屏幕上</p><p>配置如下</p><p>（1）开启输入捕获的直接通道和简介通道</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407142227325.png" alt="输入捕获配置1"></p><p>（2）开启GPIO_Output，实现对超声波模块的激活。</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407142227128.png" alt="输入捕获配置2"></p><p>（3）开启输入捕获中断</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407142227993.png" alt="输入捕获配置3"></p><p>（4）开启相应的两个通道，分别设置为上升沿和下降沿，直接与间接。</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407142228378.png" alt="输入捕获配置4"></p><p>所用到的HAL库函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)</span><br><span class="line">&#123;</span><br><span class="line">//输入捕获中断回调函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HAL_TIM_ReadCapturedValue(htim,TIM_CHANNEL_3)</span><br><span class="line"></span><br><span class="line">HAL_TIM_Base_Start(&amp;htim1);//开启定时器</span><br><span class="line"></span><br><span class="line">HAL_TIM_IC_Start(&amp;htim1,TIM_CHANNEL_3);</span><br><span class="line">//开启输入捕获，第一个为定时器操作的指针，第二个为通道</span><br><span class="line"></span><br><span class="line">HAL_TIM_IC_Start_IT(&amp;htim1,TIM_CHANNEL_4);</span><br><span class="line">//开启输入捕获，中断完成后提示，所以用_IT;第一个为定时器操作的指针，第二个为通道</span><br><span class="line"></span><br><span class="line">__HAL_TIM_SET_COUNTER(&amp;htim1,0);//置零计数器，防止达到设置的计数周期的上限，触发自动重装载</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">/* USER CODE BEGIN Includes */</span><br><span class="line">#include &quot;oled.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">/* USER CODE END Includes */</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/* USER CODE BEGIN 0 */</span><br><span class="line">int up=0;</span><br><span class="line">int down =0;</span><br><span class="line">float distance=0;</span><br><span class="line">void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)&#123;//输入捕获中断回调函数</span><br><span class="line"></span><br><span class="line">   if(htim==&amp;htim1 &amp;&amp; htim-&gt;Channel==HAL_TIM_ACTIVE_CHANNEL_4)</span><br><span class="line">   &#123;</span><br><span class="line">   //注意变量为HAL_TIM_ACTIVE_CHANNEL_X</span><br><span class="line">   </span><br><span class="line">   up = HAL_TIM_ReadCapturedValue(htim,TIM_CHANNEL_3);</span><br><span class="line">   down = HAL_TIM_ReadCapturedValue(htim,TIM_CHANNEL_4);</span><br><span class="line">   distance = ((down-up)*0.034)/2;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/* USER CODE END 0 */</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"> /* USER CODE BEGIN 2 */</span><br><span class="line">  HAL_Delay(20);</span><br><span class="line">  OLED_Init();</span><br><span class="line"> HAL_TIM_Base_Start (&amp;htim1);//开启定时器</span><br><span class="line"> HAL_TIM_IC_Start (&amp;htim1,TIM_CHANNEL_3);//开始输入捕获</span><br><span class="line"> HAL_TIM_IC_Start_IT (&amp;htim1,TIM_CHANNEL_4);//开启输入捕获（中断）</span><br><span class="line"> char message[20]=&quot;&quot;;</span><br><span class="line">  /* USER CODE END 2 */</span><br><span class="line"></span><br><span class="line">  /* Infinite loop */</span><br><span class="line">  /* USER CODE BEGIN WHILE */</span><br><span class="line">  while (1)</span><br><span class="line">  &#123;</span><br><span class="line">HAL_GPIO_WritePin(Trig_GPIO_Port,Trig_Pin,GPIO_PIN_SET);</span><br><span class="line">HAL_Delay(1);</span><br><span class="line">HAL_GPIO_WritePin(Trig_GPIO_Port,Trig_Pin,GPIO_PIN_RESET);</span><br><span class="line">//根据手册给超声波模块一个输入电压</span><br><span class="line">__HAL_TIM_SET_COUNTER(&amp;htim1,0);//置零计数周期，防止超出上限</span><br><span class="line">HAL_Delay(20);</span><br><span class="line"></span><br><span class="line">OLED_NewFrame();</span><br><span class="line">sprintf(message,&quot;距离 ：%.2fcm&quot;,distance);</span><br><span class="line">OLED_PrintString(10,10,message,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">OLED_ShowFrame();</span><br><span class="line">HAL_Delay(500);//在OLED屏幕上显示</span><br><span class="line"></span><br><span class="line">    /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">    /* USER CODE BEGIN 3 */</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h1>一些主要参考资料</h1><p>1.<a href="https://www.bilibili.com/video/BV11u4y1A7gS/?spm_id_from=pageDriver&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">【STM32】第16集 动画告诉你, STM32的定时器到底怎么回事_哔哩哔哩_bilibili</a></p><p>2.<a href="https://www.bilibili.com/video/BV1N94y1u7Uz/?spm_id_from=pageDriver&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">【STM32】动画讲解定时器外部时钟 &amp; 实战传送带测速装置_哔哩哔哩_bilibili</a></p><p>3.<a href="https://www.bilibili.com/video/BV1mU421o7vt/?spm_id_from=pageDriver&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">【STM32】一看就懂的定时器从模式讲解_哔哩哔哩_bilibili</a></p><p>4.<a href="https://www.bilibili.com/video/BV1HM4m1R75B/?p=21&amp;spm_id_from=pageDriver">【STM32】动画讲解输入捕获 并实现超声波测距_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32学习（六）时钟源与时钟树</title>
      <link href="/2024/07/10/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%97%B6%E9%92%9F%E6%BA%90%E4%B8%8E%E6%97%B6%E9%92%9F%E6%A0%91/"/>
      <url>/2024/07/10/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%97%B6%E9%92%9F%E6%BA%90%E4%B8%8E%E6%97%B6%E9%92%9F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1>相关名词的简要介绍</h1><p>时钟源与时钟树的主体部分如下图所示：</p><p>内部时钟：由单片机内部决定；</p><p>外部时钟：由晶振决定；</p><p>PLL锁相环：提供一个倍频器的作用（作用之一）；</p><p>SYSCLK：系统时钟；</p><p>HCLK：AHB（先进高性能总线）的时钟线；</p><p>内存、内核、DMA：频率和HCLK保持一致；</p><p>APB1：USART2-5、SPI2-3、IIC、USB、CAN、通用定时器、基本定时器</p><p>APB2：USART1、SPI1、GPIO、ADC、高级定时器</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407102057211.png" alt="部分图"></p><p>FCLK：为中断采样提供信号，低功耗模式唤醒，在HCLK停止的情况下运行；</p><p>TO FLITFDCLK：flash编程接口的时钟，信号来源HSI；</p><p>TO USB：USB提供功能，来自PPL锁相环；</p><p>CSS：时钟安全系统，在HSE与PLCLK的情况下产生紧急制动，切换为HSI，保障时钟的稳定；</p><p>RTC和IWDG：实时时钟与看门狗，由LSI、LSE、和HSE的128分频输入；</p><p>MCO： cubemx中勾选相应的时钟输出功能，可以将时钟输出（不常用）。</p><p>总图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407102057367.png" alt="时钟源与时钟线总图"></p><h1>一些主要参考资料</h1><p>1.<a href="https://www.bilibili.com/video/BV1ph4y1e7Ey/?p=17&amp;spm_id_from=pageDriver">【STM32】超清晰STM32时钟树动画讲解_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32学习（五）IIC</title>
      <link href="/2024/07/06/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89IIC/"/>
      <url>/2024/07/06/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89IIC/</url>
      
        <content type="html"><![CDATA[<h1>一些前置知识</h1><h2 id="IIC的基本原理">IIC的基本原理</h2><p>IIC串行总线有两根信号线，一根是双向的<strong>数据线SDA</strong>，另一根是<strong>时钟线SCL。<strong>两条线都接上拉电阻，以确保</strong>总线空闲时刻为高电平</strong>，其中时钟信号是由主控器件产生。IIC总线支持多设备连接，允许多主机存在，对于并联在一条总线上的每个IIC设备都有唯一的地址**（即靠地址来区分每一个IIC设备）。**</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407101424310.png" alt="IIC"></p><h4 id="起始信号"><strong>起始信号</strong></h4><p>当时钟线（SCL）为高平时，数据线（SDA）从高电平跳变到低电平。</p><h4 id="终止信号"><strong>终止信号</strong></h4><p>当时钟线（SCL）为高平时，数据线（SDA）从低电平跳变到高电平。</p><h4 id="应答信号"><strong>应答信号</strong></h4><p>主机每发送一个字节（8个bit），就在<strong>第9个时钟脉冲期间释放数据线（SDA）</strong>，由从机反馈一个应答信号。</p><ul><li><p>应答信号**（SDA）为低电平**时，规定为有效应答位（ACK，简称应答位），表示从机成功地接收了该字节。</p></li><li><p>应答信号**（SDA）为高电平**时，规定为非应答位（NACK），一般表示从机接收该字节没有成功。</p></li></ul><h1>IIC的三种模式</h1><p>类似串口，iic同时也有相应的三种通信模式。</p><h2 id="轮询模式">轮询模式</h2><p>从上至下一次为速度模式（标准100000，快速400000），其余一般不动。</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407101706713.png" alt="轮询模式"></p><p>主要用到的HAL库代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Master_Receive(&amp;hic1,AHT20_ADDRESS,&amp;readBUffer,3,HAL_MAX_DELAY);  </span><br><span class="line">//接收函数，第一个是iic的地址指针，第二个是获取数据的地址，第三个为接收的数组地址，第四个是接收数据的长度，第五个是最长等待时间</span><br><span class="line"></span><br><span class="line">HAL_I2C_Master_Transmit(&amp;hic1,AHT20_ADDRESS,&amp;sendBUffer,3,HAL_MAX_DELAY);  </span><br><span class="line">//接收函数，第一个是iic的地址指针，第二个是将发送数据的地址，第三个为发送的数组地址，第四个是发送数据的长度，第五个是最长等待时间</span><br></pre></td></tr></table></figure><p>实践一：AHT20的读取串口发送</p><p>首先，移植相应的AHT20驱动，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line">  AHT20_Init();//初始化AHT20</span><br><span class="line">  float temperature = 0.0, humidity = 0.0;</span><br><span class="line">  char message[50];//定义相关的变量、数组名称</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">while (1) &#123;</span><br><span class="line">    AHT20_Measure();//读取AHT20</span><br><span class="line">    temperature = AHT20_Tempurature();</span><br><span class="line">    humidity = AHT20_Humidity();</span><br><span class="line">    sprintf(message, &quot;Temperature: %.2f, Humidity: %.2f%%\r\n&quot;, temperature, humidity);</span><br><span class="line">    //拼接字符串</span><br><span class="line">    HAL_UART_Transmit(&amp;huart2, (uint8_t *)message, strlen(message), HAL_MAX_DELAY);</span><br><span class="line">    HAL_Delay(1000);</span><br><span class="line">    /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">    /* USER CODE BEGIN 3 */</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="中断模式">中断模式</h2><h3 id="状态机的概念">状态机的概念</h3><p>在实际对一个模块的操作中，我们需要将其完成的工作模块化，这样方便我们对于它运行的状态进行判定。</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407101706193.png" alt="状态机"></p><h2 id="中断模式代码">中断模式代码</h2><p>开启中断模式</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407101539462.png" alt="中断模式"></p><p>所用到的HAL库函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)&#123;</span><br><span class="line">//接收完成中断</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)&#123;</span><br><span class="line">//发送完成中断</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HAL_I2C_Master_Receive_IT(&amp;hic1,AHT20_ADDRESS,&amp;readBUffer,3,HAL_MAX_DELAY);  </span><br><span class="line">//接收函数，第一个是iic的地址指针，第二个是获取数据的地址，第三个为接收的数组地址，第四个是接收数据的长度，第五个是最长等待时间</span><br><span class="line"></span><br><span class="line">HAL_I2C_Master_Transmit_IT(&amp;hic1,AHT20_ADDRESS,&amp;sendBUffer,3,HAL_MAX_DELAY);  </span><br><span class="line">//接收函数，第一个是iic的地址指针，第二个是将发送数据的地址，第三个为发送的数组地址，第四个是发送数据的长度，第五个是最长等待时间</span><br></pre></td></tr></table></figure><p>实践一：AHT20的读取串口发送</p><p>i2c.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* USER CODE BEGIN 0 */</span><br><span class="line"></span><br><span class="line">void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)&#123;</span><br><span class="line">   if(hi2c == &amp;hi2c1)&#123;</span><br><span class="line">   aht20_State == 2;</span><br><span class="line">&#125;//发送信息完成中断</span><br><span class="line"></span><br><span class="line">void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)&#123;</span><br><span class="line">   if(hi2c == &amp;hi2c1)&#123;</span><br><span class="line">   aht20_State == 4;</span><br><span class="line">&#125;//接收信息完成中断</span><br><span class="line"></span><br><span class="line">/* USER CODE END 0 */</span><br></pre></td></tr></table></figure><p>main.h</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN EC */</span><br><span class="line"></span><br><span class="line">extern uint8_t aht20_State;//提前变量，以便全局使用</span><br><span class="line"></span><br><span class="line">/* USER CODE END EC */</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>main.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">AHT20_Init();</span><br><span class="line">float temperature = 0.0, humidity = 0.0;</span><br><span class="line">char message[50];</span><br><span class="line"></span><br><span class="line">/* USER CODE END 2 */</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">while (1) &#123;</span><br><span class="line"></span><br><span class="line">if(aht20_State == 0)&#123;</span><br><span class="line">     AHT20_Measure();</span><br><span class="line">     aht20_State == 1;</span><br><span class="line">  &#125;else if(aht20_State == 2)&#123;</span><br><span class="line">     HAL_Delay(75);</span><br><span class="line">     AHT20_Get();</span><br><span class="line">     aht20_State == 3;</span><br><span class="line">  &#125;else if(aht20_State == 4)&#123;</span><br><span class="line">    AHT20_Analysis(&amp;temperature,&amp;humidity);</span><br><span class="line">    sprintf(message, &quot;Temperature: %.2f, Humidity: %.2f%%\r\n&quot;, temperature, humidity);</span><br><span class="line">    HAL_UART_Transmit(&amp;huart2, (uint8_t *)message, strlen(message), HAL_Delay(1000);</span><br><span class="line">    aht20_State == 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">  /* USER CODE BEGIN 3 */</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="DMA模式">DMA模式</h2><p>开启DMA模式</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407101539521.png" alt="DMA模式"></p><p>所用到的HAL库函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)&#123;</span><br><span class="line">//接收完成中断</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)&#123;</span><br><span class="line">//发送完成中断</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HAL_I2C_Master_Receive_DMA(&amp;hic1,AHT20_ADDRESS,&amp;readBUffer,3,HAL_MAX_DELAY);  </span><br><span class="line">//接收函数，第一个是iic的地址指针，第二个是获取数据的地址，第三个为接收的数组地址，第四个是接收数据的长度，第五个是最长等待时间</span><br><span class="line"></span><br><span class="line">HAL_I2C_Master_Transmit_DMA(&amp;hic1,AHT20_ADDRESS,&amp;sendBUffer,3,HAL_MAX_DELAY);  </span><br><span class="line">//接收函数，第一个是iic的地址指针，第二个是将发送数据的地址，第三个为发送的数组地址，第四个是发送数据的长度，第五个是最长等待时间</span><br></pre></td></tr></table></figure><p>代码实践</p><p>实践一：结合OLED和AHT20制作简易温湿度计</p><p>main.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> /* USER CODE BEGIN Includes */</span><br><span class="line">   #include &quot;oled.h&quot;</span><br><span class="line">   #include &quot;aht20.h&quot;</span><br><span class="line">   #include &quot;stdio.h&quot;</span><br><span class="line">   #include &quot;string.h&quot;</span><br><span class="line"> /* USER CODE END Includes */</span><br><span class="line"> </span><br><span class="line"> /* USER CODE BEGIN 2 */</span><br><span class="line">     HAL_Delay(20);</span><br><span class="line">     OLED_Init();</span><br><span class="line"> AHT20_Init();</span><br><span class="line">     float temperature = 0.0, humidity = 0.0;</span><br><span class="line"> char message[50];//初始化相应的的变量和函数</span><br><span class="line"> /* USER CODE END 2 */</span><br><span class="line"> </span><br><span class="line">while (1)</span><br><span class="line">  &#123;</span><br><span class="line">    /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">    /* USER CODE BEGIN 3 */</span><br><span class="line"> </span><br><span class="line">   AHT20_Measure();</span><br><span class="line">temperature=AHT20_Temperature();</span><br><span class="line">humidity=AHT20_Humidity();  </span><br><span class="line"></span><br><span class="line">    OLED_NewFrame();//准备新的图像</span><br><span class="line"></span><br><span class="line">OLED_DrawImage(15,0,&amp;temperatureImgImg,OLED_COLOR_NORMAL);</span><br><span class="line">//画图，x，y,图像指针，字符颜色</span><br><span class="line">sprintf(message,&quot;%.1f℃&quot;,temperature);//拼接字符串</span><br><span class="line">OLED_PrintString(45,15,message,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">//打印字符串，x，y,字符串指针地址，字符颜色</span><br><span class="line"></span><br><span class="line">OLED_DrawImage(15,30,&amp;humidityImgImg,OLED_COLOR_NORMAL);</span><br><span class="line">sprintf(message,&quot;%.1f%%&quot;,humidity);</span><br><span class="line">OLED_PrintString(45,40,message,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line"></span><br><span class="line">OLED_ShowFrame();//展示图像</span><br></pre></td></tr></table></figure><p>字体、图片需要用取模助手取模，放在font.c文件中，图片名称需要extern 提前变量在font.h中，以便全局调用。</p><h1>一些参考资料</h1><p>1.<a href="https://www.bilibili.com/video/BV1QN411D7ak/?spm_id_from=333.788&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">【STM32入门教程-2024】第12集 IIC通信与温湿度传感器AHT20(DHT20)_哔哩哔哩_bilibili</a></p><p>2.<a href="https://www.bilibili.com/video/BV1AN41127VL/?spm_id_from=333.788&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">【STM32入门教程-2024】第13集 IIC的中断与DMA以及状态机编程_哔哩哔哩_bilibili</a></p><p>3.<a href="https://www.bilibili.com/video/BV19u4y197df/?spm_id_from=333.788&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">【STM32入门教程-2024】第14集 如何在OLED屏幕上挥毫_哔哩哔哩_bilibili</a></p><p>4.<a href="https://www.bilibili.com/video/BV18u4y1e7PR/?spm_id_from=333.788&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">【STM32·番外】挑战5分钟制作温湿度计(A/DHT20+OLED)_哔哩哔哩_bilibili</a></p><p>5.<a href="https://blog.csdn.net/weixin_54076783/article/details/129597296?ops_request_misc=%7B%22request%5Fid%22%3A%22172049332416800197086902%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=172049332416800197086902&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-129597296-null-null.142%5Ev100%5Epc_search_result_base4&amp;utm_term=iicstm32&amp;spm=1018.2226.3001.4187">STM32之IIC_stm32 iic-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32学习（四）串口通信</title>
      <link href="/2024/07/02/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/"/>
      <url>/2024/07/02/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1>一些前置知识</h1><h2 id="并、串行通信的区别">并、串行通信的区别</h2><table><thead><tr><th style="text-align:left"></th><th>并行通信</th><th>串行通信</th></tr></thead><tbody><tr><td style="text-align:left">传输原理</td><td>数据各个位同时传输</td><td>数据按位顺序传输</td></tr><tr><td style="text-align:left">优点</td><td>速度快</td><td>占用引脚资源少</td></tr><tr><td style="text-align:left">缺点</td><td>占用引脚资源多</td><td>速度相对较慢</td></tr></tbody></table><h2 id="串行通信的分类">串行通信的分类</h2><p>（*）1、按照数据传送方向，分为：</p><p>单工：数据传输只支持数据在一个方向上传输；<br>半双工：允许数据在两个方向上传输。但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；它不需要独立的接收端和发送端，两者可以合并一起使用一个端口。<br>全双工：允许数据同时在两个方向上传输。因此，全双工通信是两个单工通信方式的结合，需要独立的接收端和发送端。</p><p>（***） 2、按照通信方式，分为：</p><p><strong>同步通信</strong>：带时钟同步信号传输。比如：SPI，IIC通信接口。<br><strong>异步通信</strong>：不带时钟同步信号。比如：UART(通用异步收发器)，单总线。<br>在同步通讯中，收发设备上方会使用一根信号线传输信号，在时钟信号的驱动下双方进行协调，同步数据。例如，通讯中通常双方会统一规定在时钟信号的上升沿或者下降沿对数据线进行采样。</p><p>在异步通讯中不使用时钟信号进行数据同步，它们直接在数据信号中穿插一些用于同步的信号位，或者将主题数据进行打包，以数据帧的格式传输数据。通讯中还需要双方规约好数据的传输速率（也就是波特率）等，以便更好地同步。常用的波特率有4800bps、9600bps、115200bps等。</p><p>在同步通讯中，数据信号所传输的内容绝大部分是有效数据，而异步通讯中会则会包含数据帧的各种标识符，所以同步通讯效率高，但是同步通讯双方的时钟允许误差小，稍稍时钟出错就可能导致数据错乱，异步通讯双方的时钟允许误差较大。</p><h1>三种串口通信方式</h1><h2 id="轮询方式">轮询方式</h2><p>特点：发一个，接受一个。</p><p>缺点：占用cpu，利用率较低。</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407032045432.png" alt="轮询模式"></p><p>波特率：常见的用115200，9600Bits/s。需要保证<strong>接收端和发送端波特率一致</strong>。</p><p>字节长度：8字节，外加前面1位起始位，后面1位结束位，一共10位。</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407032045638.png" alt="各种参数"></p><h2 id="轮询模式代码">轮询模式代码</h2><p>主要用到的hal库函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive(&amp;huart1,receveData,2,HAL_MAX_DELAY);</span><br><span class="line">//接收，第一位为串口地址，第二位为指针，第三位为数组长度，第四位为等待最大时长（HAL_MAX_DELAY为无限制时长）</span><br><span class="line"></span><br><span class="line">HAL_UART_Transmit(&amp;huart1,receveData,2,100);</span><br><span class="line">//发送，第一位为串口地址，第二位为指针，第三位为数组长度，第四位为等待最大时长（HAL_MAX_DELAY为无限制时长）</span><br></pre></td></tr></table></figure><h3 id="代码实践">代码实践</h3><p>通过轮询模式实现串口收发数据：</p><p>实践一：实现收发“Hello World”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">char message[]=&quot;Hello World&quot;</span><br><span class="line"></span><br><span class="line">  /* USER CODE END 2 */</span><br><span class="line"></span><br><span class="line">  /* Infinite loop */</span><br><span class="line">  /* USER CODE BEGIN WHILE */</span><br><span class="line">  while (1)</span><br><span class="line">  &#123;</span><br><span class="line">    /* USER CODE END WHILE */</span><br><span class="line">        </span><br><span class="line">        HAL_UART_Transmit(&amp;huart1,(uint8_t*)message,strlen(message),100);</span><br><span class="line">        //char强转为uint8_t类型</span><br><span class="line">        HAL_Delay(1000);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /* USER CODE BEGIN 3 */</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>实践二：实现发送对应信息，点亮对应小灯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">uint8_t  receveData[2];</span><br><span class="line"></span><br><span class="line">  /* USER CODE END 2 */</span><br><span class="line"></span><br><span class="line">  /* Infinite loop */</span><br><span class="line">  /* USER CODE BEGIN WHILE */</span><br><span class="line">  while (1)</span><br><span class="line">  &#123;</span><br><span class="line">    /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">HAL_UART_Receive(&amp;huart1,receveData,2,HAL_MAX_DELAY);</span><br><span class="line">HAL_UART_Transmit(&amp;huart1,receveData,2,100);</span><br><span class="line">if(receveData[1]==&#x27;1&#x27;&amp;&amp;receveData[0]==&#x27;R&#x27;)&#123;</span><br><span class="line">HAL_GPIO_TogglePin(LED_RED_GPIO_Port,LED_RED_Pin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(receveData[1]==&#x27;1&#x27;&amp;&amp;receveData[0]==&#x27;Y&#x27;)&#123;</span><br><span class="line">HAL_GPIO_WritePin(LED_YELLOW_GPIO_Port,LED_YELLOW_Pin,GPIO_PIN_SET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(receveData[1]==&#x27;1&#x27;&amp;&amp;receveData[0]==&#x27;G&#x27;)&#123;</span><br><span class="line">HAL_GPIO_WritePin(LED_GREEN_GPIO_Port,LED_GREEN_Pin,GPIO_PIN_SET);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">      //实现对传输信息的接收，并点亮对应的引脚</span><br><span class="line">    /* USER CODE BEGIN 3 */</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h2 id="中断模式">中断模式</h2><p>和轮询类似，只是CPU在寄存器空闲时可以处理其他事情。大致原理如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407032045666.png" alt="中断模式"></p><p>transmit发送和轮询一样，而receive接收，由于不会等待，所以在回调函数中书写相关的代码逻辑。</p><p>你需要在cubemx中开启全局中断。</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407032045273.png" alt="开启全局中断"></p><h2 id="中断模式代码">中断模式代码</h2><p>主要用到的hal库函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</span><br><span class="line">&#123; </span><br><span class="line">     //弱函数，中断回调函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  HAL_UART_Transmit_IT(&amp;huart1,receveData,2);//第一个为串口，第二个为指针，第三个为数组长度</span><br><span class="line"> </span><br><span class="line">  HAL_UART_Receive_IT(&amp;huart1,receveData,2);//第一个为串口，第二个为指针，第三个为数组长度</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="代码实践-2">代码实践</h3><p>实践一：与中断的实践二功能相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN PV */</span><br><span class="line">uint8_t  receveData[2];</span><br><span class="line">/* USER CODE END PV */</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/* USER CODE BEGIN 0 */</span><br><span class="line">void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)//在中断处理函数中书写代码逻辑</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">      HAL_UART_Transmit_IT(&amp;huart1,receveData,2);</span><br><span class="line">if(receveData[1]==&#x27;1&#x27;&amp;&amp;receveData[0]==&#x27;R&#x27;)&#123;</span><br><span class="line">HAL_GPIO_TogglePin(LED_RED_GPIO_Port,LED_RED_Pin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(receveData[1]==&#x27;1&#x27;&amp;&amp;receveData[0]==&#x27;Y&#x27;)&#123;</span><br><span class="line">HAL_GPIO_WritePin(LED_YELLOW_GPIO_Port,LED_YELLOW_Pin,GPIO_PIN_SET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(receveData[1]==&#x27;1&#x27;&amp;&amp;receveData[0]==&#x27;G&#x27;)&#123;</span><br><span class="line">HAL_GPIO_WritePin(LED_GREEN_GPIO_Port,LED_GREEN_Pin,GPIO_PIN_SET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HAL_UART_Receive_IT(&amp;huart1,receveData,2);//每次结束后，开启下一次的接收</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* USER CODE END 0 */</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/* USER CODE BEGIN 2 */</span><br><span class="line"></span><br><span class="line">HAL_UART_Receive_IT(&amp;huart1,receveData,2);//在main函数中开启接受的中断</span><br><span class="line"></span><br><span class="line"> /* USER CODE END 2 */</span><br></pre></td></tr></table></figure><h2 id="DMA模式">DMA模式</h2><p>搬运数据，创建通道，等待完成后通过中断处理函数通知cpu。</p><p>优点：进一步解放cpu。</p><p>开启DMA：（从左至右，从上至下，顺时针）开启的DMA通道，数据传输方向，优先级（一般默认），接收端和发送端是否地址自增，模式。</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407032046322.png" alt="DMA"></p><h2 id="DMA模式代码">DMA模式代码</h2><p>主要用到的hal库函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Transmit_DMA(&amp;huart1,receveData,2);//第一个为串口，第二个为指针，第三个为数组长度</span><br><span class="line"></span><br><span class="line">HAL_UART_Receive_DMA(&amp;huart1,receveData,2);//第一个为串口，第二个为指针，第三个为数组长度</span><br></pre></td></tr></table></figure><p>实践与上述两种方法类似，略。</p><h2 id="实现不定长数据接收">实现不定长数据接收</h2><p>主要用到的hal库函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__weak void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)</span><br><span class="line">//所用的中断回调函数</span><br><span class="line"></span><br><span class="line"> HAL_UARTEx_ReceiveToIdle(&amp;huart1,receveData,sizeof(receveData));</span><br><span class="line"> </span><br><span class="line"> HAL_UARTEx_ReceiveToIdle_IT(&amp;huart1,receveData,sizeof(receveData));</span><br><span class="line"> </span><br><span class="line"> HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1,receveData,sizeof(receveData));</span><br><span class="line"> //第三位是最大接收的长度，不大于数组长度</span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>此方式下DMA的缺点：传输过半中断会触发中断，即发送一半就会截断。</p><p>通过取消使能串口，取消中断。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern DMA_HandleTypeDef hdma_usart1_rx;</span><br><span class="line">//在main.h中进行定义（如果勾选了为每个外设生成单独的.c.h文件）</span><br><span class="line"></span><br><span class="line">__HAL_DMA_DISABLE_IT(&amp;hdma_usart1_rx,DMA_IT_HT);</span><br><span class="line">//第一个为dma的串口，在中断处理函数和main函数中都要添加</span><br></pre></td></tr></table></figure><h2 id="不定长数据接收代码">不定长数据接收代码</h2><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN PV */</span><br><span class="line"></span><br><span class="line">uint8_t  receveData[5];</span><br><span class="line"></span><br><span class="line">/* USER CODE END PV */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* USER CODE BEGIN 0 */</span><br><span class="line"></span><br><span class="line">void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if(huart==&amp;huart1)</span><br><span class="line">&#123;</span><br><span class="line">   HAL_UART_Transmit_DMA(&amp;huart1,receveData,Size);</span><br><span class="line">           HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1,receveData,sizeof(receveData));</span><br><span class="line">           //每次结束后都开启接收</span><br><span class="line">   __HAL_DMA_DISABLE_IT(&amp;hdma_usart1_rx,DMA_IT_HT);</span><br><span class="line">   //取消使能</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/* USER CODE END 0 */</span><br><span class="line">...</span><br><span class="line"> /* USER CODE BEGIN 2 */</span><br><span class="line"></span><br><span class="line">           HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1,receveData,sizeof(receveData));</span><br><span class="line">           //开启第一次接收</span><br><span class="line">          __HAL_DMA_DISABLE_IT(&amp;hdma_usart1_rx,DMA_IT_HT);//取消使能</span><br><span class="line"></span><br><span class="line">  /* USER CODE END 2 */</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>主要参考资源</h1><p>1.<a href="https://blog.csdn.net/u013407012/article/details/102465403?ops_request_misc=%7B%22request%5Fid%22%3A%22171997361916800188521398%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171997361916800188521398&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-102465403-null-null.142%5Ev100%5Epc_search_result_base4&amp;utm_term=%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1stm32&amp;spm=1018.2226.3001.4187">【STM32】串口通信基本原理（超基础、详细版）_stm32串口通信工作原理-CSDN博客</a></p><p>2.<a href="https://www.bilibili.com/video/BV1Na4y1T7VQ/?spm_id_from=333.788&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">【keysking的STM32教程】 第8集 STM32的串口通信_哔哩哔哩_bilibili</a></p><p>3.<a href="https://www.bilibili.com/video/BV1bc411J7Tv/?spm_id_from=333.788&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">【STM32入门教程-2024】第9集 STM32串口原理与串口中断模式收发 | keysking的stm32教程_哔哩哔哩_bilibili</a></p><p>4.<a href="https://www.bilibili.com/video/BV1do4y1F7wt/?spm_id_from=333.788&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">【工作STM32】第10集 STM32串口DMA模式与收发不定长数据 | keysking的stm32教程_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32学习（三）外部中断</title>
      <link href="/2024/05/01/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/"/>
      <url>/2024/05/01/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="一些前置知识">一些前置知识</h2><h3 id="内部原理简介">内部原理简介</h3><p>首先信号进入输入驱动器，详情见上一篇文章。</p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407021507259.png" alt="输入驱动器" style="zoom:80%;"><p>信号进入后顺序如下：</p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407021507544.png" alt="边路检测电路" style="zoom: 67%;"><p><strong>边路检测电路</strong>：信号进来首先经过上升下降选择寄存器，由CubeMx进行配置。第一个即为寄存器的配置。第二个为输入信号上拉下拉的配置。</p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407021507150.png" alt="上拉下拉处理中断" style="zoom: 33%;"><p>接着，经过一个或门。</p><p><strong>软件中断寄存器</strong>：模拟产生中断，用处可暂时忽略。</p><p><strong>事件屏蔽寄存器</strong>：非相关知识，之后了解。</p><p>输入后，</p><p><strong>请求挂起寄存器</strong>：相应位置变为’1’,即输入高电平信号。</p><p><strong>中断屏蔽寄存器</strong>：CubeMx已配置好。</p><p>经过与门，进入NVIC。</p><p>NVIC主要掌管中断向量表。主要由抢占优先级和响应优先级。主要规则如下：</p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407021507436.png" style="zoom: 33%;"><p>因此，如要在中断处理函数中使用HAL_DELAY，需要线配置“时钟滴答”的优先级，才可打断中断，实现延时。</p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407021507652.png" alt="设置优先级" style="zoom: 67%;"><h2 id="代码实践">代码实践</h2><h3 id="外部中断实现摁键控制亮灭">外部中断实现摁键控制亮灭</h3><p>在stm32f103xx_it.c中进行改写，如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void EXTI9_5_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">  /* USER CODE BEGIN EXTI9_5_IRQn 0 */</span><br><span class="line">  </span><br><span class="line">HAL_Delay(10);</span><br><span class="line">if(HAL_GPIO_ReadPin(KEY_GPIO_Port ,KEY_Pin)==GPIO_PIN_RESET)&#123;</span><br><span class="line">HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin);</span><br><span class="line">&#125;//实现摁键摁下，小灯翻转亮灭</span><br><span class="line"></span><br><span class="line">  /* USER CODE END EXTI9_5_IRQn 0 */</span><br><span class="line">  HAL_GPIO_EXTI_IRQHandler(KEY_Pin);</span><br><span class="line">  /* USER CODE BEGIN EXTI9_5_IRQn 1 */</span><br><span class="line"></span><br><span class="line">  /* USER CODE END EXTI9_5_IRQn 1 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些参考资源">一些参考资源</h2><p>1.【keysking的STM32教程】 第7集 深入讲解STM32中断_哔哩哔哩_bilibili</p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32学习（二）GPIO</title>
      <link href="/2024/04/06/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89GPIO/"/>
      <url>/2024/04/06/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89GPIO/</url>
      
        <content type="html"><![CDATA[<h2 id="一些前备知识">一些前备知识</h2><h3 id="两种MOS管">两种MOS管</h3><p>首先，在翻阅一些B站上的视频后，我发现大部分GPIO都讲到了其内部结构，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407021522441.png" alt="GPIO"></p><p>由于本人没学过模电数电，故不了解mos管，查阅后，了解后大致如下 ：</p><p>1.分为p mos和n mos，两种区别仅为底下的半导体不同，P型的是以p型为衬底，N型同理。n型半导体是硅掺5价磷，p掺3价硼。故前者带电子，后者有空穴。</p><p>2.n mos管实际上是由两个半导体组成，再加上一个栅格来控制导通（如果没有栅格，则无论正反向均导通不了），栅格通电，吸引电子，挤掉空穴，形成n沟道，导通。p型反之。箭头代表电子移动方向。如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407021522092.png" alt="两种MOS管"></p><p>3.n mos需要达到一定电压才可导通，p则需要小于一定电压。</p><h3 id="上拉电阻和下拉电阻">上拉电阻和下拉电阻</h3><p>1.设置上拉电阻，控制默认为高电压，当外部电路为低电压，产生数字信号，读取数据。</p><p>2.设置下拉电阻，控制默认为低电压，当外部电路为高电压，产生数字信号，读取数据。</p><h3 id="TTL肖特基触发器（施密特触发器）">TTL肖特基触发器（施密特触发器）</h3><p>设置阈值电压，消除电压的波动影响，将图形变化变为数字变化（01变化）。</p><h2 id="GPIO的八种模式">GPIO的八种模式</h2><p>（1）模拟输入:直接读取具体电压值，上拉下拉断开</p><p>（2）上拉输入：上拉电阻闭合</p><p>（3）下拉输入：下拉电阻闭合</p><p>（4）复用功能输入：一些外部模块的输出，如串口模块</p><p>（5）推挽输出：芯片自身提供电源</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407021522463.png" alt="推挽和开漏"></p><p>（6）开漏输出：外接提供电源</p><p>（7）复用推挽输出：外设模块，串口、iiic等</p><p>（8）复用开漏输出：同上</p><h2 id="GPIO相应的HAL库函数">GPIO相应的HAL库函数</h2><p>GPIO_Mode_AIN 模拟输入</p><p>GPIO_Mode_IN_FLOATING 浮空输入</p><p>GPIO_Mode_IPD 下拉输入</p><p>GPIO_Mode_IPU 上拉输入</p><p>GPIO_Mode_Out_OD 开漏输出</p><p>GPIO_Mode_Out_PP 推挽输出</p><p>GPIO_Mode_AF_OD 复用开漏输出</p><p>GPIO_Mode_AF_PP 复用推挽输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init);           #初始IO口状态      </span><br><span class="line"></span><br><span class="line">HAL_GPIO_DeInit(GPIO_TypeDef *GPIOx, uint32_t GPIO_Pin);                   #重置IO口状态 </span><br><span class="line"></span><br><span class="line">HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);                  #读取IO口状态 </span><br><span class="line"></span><br><span class="line">HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState);  #设置IO口状态 </span><br><span class="line"></span><br><span class="line">*PinState：GPIO 端口输出的状态，可以是 GPIO_PIN_RESET 或 GPIO_PIN_SET     </span><br><span class="line"></span><br><span class="line">HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);         #转换IO口状态      </span><br><span class="line"></span><br><span class="line">HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);                   #锁定IO口状态</span><br><span class="line"></span><br><span class="line">HAL_Delay()                                                                 #()填毫秒数</span><br></pre></td></tr></table></figure><h2 id="实践led点亮-有源蜂鸣器的发音">实践led点亮/有源蜂鸣器的发音</h2><p>Cubemx对应引脚设置GPIO_Output,生成代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">while (1)</span><br><span class="line"> &#123;</span><br><span class="line">   /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">   /* USER CODE BEGIN 3 */</span><br><span class="line"></span><br><span class="line">     HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState);  #填入你的IO口及对应状态</span><br><span class="line">     HAL_Delay(500);</span><br><span class="line">     HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState);  #填入你的IO口及对应相反状态</span><br><span class="line">     HAL_Delay(500);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>或者，你可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while (1)</span><br><span class="line"> &#123;</span><br><span class="line">   /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">   /* USER CODE BEGIN 3 */</span><br><span class="line"></span><br><span class="line">    HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);           #填入你的IO口及对应状态</span><br><span class="line">     HAL_Delay(500);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>则可以实现led的闪烁和蜂鸣器的发音。</p><h2 id="摁键的控制-光敏传感器的传感">摁键的控制/光敏传感器的传感</h2><p>Cubemx对应引脚设置GPIO_INput,生成代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">while (1)</span><br><span class="line"> &#123;</span><br><span class="line">   /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">   /* USER CODE BEGIN 3 */</span><br><span class="line">   </span><br><span class="line">    HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);           #填入你的IO口</span><br><span class="line">    </span><br><span class="line">    if(HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)==GPIO_PIN_RESET)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">       HAL_Delay(10);   #延时消抖     </span><br><span class="line">       </span><br><span class="line">         if(HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)==GPIO_PIN_RESET)  #简单的摁键消抖</span><br><span class="line">          &#123;</span><br><span class="line">            #摁键/光敏传感器所控制的模块</span><br><span class="line">          &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">光敏模块引脚说明</span><br><span class="line"></span><br><span class="line">VCC：电源引脚，接单片机+5V或者3.3V。</span><br><span class="line">GND：地线，接单片机GND。</span><br><span class="line">DO：开关量输出（0或1），模块在无光条件下或光强达不到设定阈值时，DO口输出高电平；当外界环境光强超过设定阈值时，DO输出低电平。</span><br><span class="line">AO：模拟量输出（电压），与单片机AD模块相连，通过AD转换，获得准确数值。（后续中使用PA1引脚作为ADC转换，因此此处接单片机的PA1引脚）</span><br></pre></td></tr></table></figure><p>故只能实现光信号简单的控制。</p><h2 id="主要参考资源">主要参考资源</h2><p>1.<a href="https://www.bilibili.com/video/BV1th411z7sn?p=8&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">B站江科大stm32  P5-8</a></p><p>2.<a href="https://www.bilibili.com/video/BV1mU421o7vt/?spm_id_from=333.337.search-card.all.click&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">B站keysking</a></p><p>3.<a href="https://www.bilibili.com/video/BV1344y167qm?spm_id_from=333.880.my_history.page.click">B站爱上半导体</a></p><p>4.<a href="https://www.bilibili.com/video/BV1bt4y177E8?spm_id_from=333.880.my_history.page.click">维库电子市场网</a></p><p>5.<a href="https://blog.csdn.net/weixin_58632615/article/details/124729997?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=stm32hal%E5%BA%93%E5%85%89%E6%95%8F&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduweb~default-6-124729997.nonecase&amp;spm=1018.2226.3001.4450">CSDN xiang–ying</a></p><p>6.<a href="https://blog.csdn.net/qq_41968464/article/details/126856223?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171240583816800222891676%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171240583816800222891676&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-126856223-null-null.142%5Ev100%5Epc_search_result_base4&amp;utm_term=stm32hal%E5%BA%93%E5%85%89%E6%95%8F&amp;spm=1018.2226.3001.4187">CSDN 编号09527</a></p><p>7.stm32官方固件参考手册 、stm32中文参考手册</p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32学习（一）序言</title>
      <link href="/2024/04/05/stm32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%BA%8F%E8%A8%80/"/>
      <url>/2024/04/05/stm32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%BA%8F%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="学习stm32的初衷">学习stm32的初衷</h2><p>由于我参加了足基的春招，铩羽而归，发现之前所学不成体系，故以写博客的方式来梳理知识，希望可以在stm32上有些许收获。</p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
