<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>STM32学习（四）串口通信</title>
      <link href="/2024/07/02/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/"/>
      <url>/2024/07/02/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32学习（三）外部中断</title>
      <link href="/2024/05/01/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/"/>
      <url>/2024/05/01/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="一些前置知识">一些前置知识</h2><h3 id="内部原理简介">内部原理简介</h3><p>首先信号进入输入驱动器，详情见上一篇文章。</p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407021429964.png" alt="输入驱动器" style="zoom:80%;"><p>信号进入后顺序如下：</p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407021434581.png" alt="边路检测电路" style="zoom: 67%;"><p><strong>边路检测电路</strong>：信号进来首先经过上升下降选择寄存器，由CubeMx进行配置。第一个即为寄存器的配置。第二个为输入信号上拉下拉的配置。</p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407021436957.png" alt="上拉下拉处理中断" style="zoom: 33%;"><p>接着，经过一个或门。</p><p><strong>软件中断寄存器</strong>：模拟产生中断，用处可暂时忽略。</p><p><strong>事件屏蔽寄存器</strong>：非相关知识，之后了解。</p><p>输入后，</p><p><strong>请求挂起寄存器</strong>：相应位置变为’1’,即输入高电平信号。</p><p><strong>中断屏蔽寄存器</strong>：CubeMx已配置好。</p><p>经过与门，进入NVIC。</p><p>NVIC主要掌管中断向量表。主要由抢占优先级和响应优先级。主要规则如下：</p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407021434903.png" style="zoom: 33%;"><p>因此，如要在中断处理函数中使用HAL_DELAY，需要线配置“时钟滴答”的优先级，才可打断中断，实现延时。</p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202407021433027.png" alt="设置优先级" style="zoom: 67%;"><h2 id="代码实践">代码实践</h2><h3 id="外部中断实现摁键控制亮灭">外部中断实现摁键控制亮灭</h3><p>在stm32f103xx_it.c中进行改写，如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void EXTI9_5_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">  /* USER CODE BEGIN EXTI9_5_IRQn 0 */</span><br><span class="line">  </span><br><span class="line">HAL_Delay(10);</span><br><span class="line">if(HAL_GPIO_ReadPin(KEY_GPIO_Port ,KEY_Pin)==GPIO_PIN_RESET)&#123;</span><br><span class="line">HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin);</span><br><span class="line">&#125;//实现摁键摁下，小灯翻转亮灭</span><br><span class="line"></span><br><span class="line">  /* USER CODE END EXTI9_5_IRQn 0 */</span><br><span class="line">  HAL_GPIO_EXTI_IRQHandler(KEY_Pin);</span><br><span class="line">  /* USER CODE BEGIN EXTI9_5_IRQn 1 */</span><br><span class="line"></span><br><span class="line">  /* USER CODE END EXTI9_5_IRQn 1 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些参考资源">一些参考资源</h2><p>1.【keysking的STM32教程】 第7集 深入讲解STM32中断_哔哩哔哩_bilibili</p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32学习（二）GPIO</title>
      <link href="/2024/04/06/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89GPIO/"/>
      <url>/2024/04/06/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89GPIO/</url>
      
        <content type="html"><![CDATA[<h2 id="一些前备知识">一些前备知识</h2><h3 id="两种MOS管">两种MOS管</h3><p>首先，在翻阅一些B站上的视频后，我发现大部分GPIO都讲到了其内部结构，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202404071424018.png" alt="GPIO"></p><p>由于本人没学过模电数电，故不了解mos管，查阅后，了解后大致如下 ：</p><p>1.分为p mos和n mos，两种区别仅为底下的半导体不同，P型的是以p型为衬底，N型同理。n型半导体是硅掺5价磷，p掺3价硼。故前者带电子，后者有空穴。</p><p>2.n mos管实际上是由两个半导体组成，再加上一个栅格来控制导通（如果没有栅格，则无论正反向均导通不了），栅格通电，吸引电子，挤掉空穴，形成n沟道，导通。p型反之。箭头代表电子移动方向。如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202404071425466.png" alt="两种MOS管"></p><p>3.n mos需要达到一定电压才可导通，p则需要小于一定电压。</p><h3 id="上拉电阻和下拉电阻">上拉电阻和下拉电阻</h3><p>1.设置上拉电阻，控制默认为高电压，当外部电路为低电压，产生数字信号，读取数据。</p><p>2.设置下拉电阻，控制默认为低电压，当外部电路为高电压，产生数字信号，读取数据。</p><h3 id="TTL肖特基触发器（施密特触发器）">TTL肖特基触发器（施密特触发器）</h3><p>设置阈值电压，消除电压的波动影响，将图形变化变为数字变化（01变化）。</p><h2 id="GPIO的八种模式">GPIO的八种模式</h2><p>（1）模拟输入:直接读取具体电压值，上拉下拉断开</p><p>（2）上拉输入：上拉电阻闭合</p><p>（3）下拉输入：下拉电阻闭合</p><p>（4）复用功能输入：一些外部模块的输出，如串口模块</p><p>（5）推挽输出：芯片自身提供电源</p><p><img src="https://cdn.jsdelivr.net/gh/Peter-QY/photoResourse/images/202404071425898.png" alt="推挽和开漏"></p><p>（6）开漏输出：外接提供电源</p><p>（7）复用推挽输出：外设模块，串口、iiic等</p><p>（8）复用开漏输出：同上</p><h2 id="GPIO相应的HAL库函数">GPIO相应的HAL库函数</h2><p>GPIO_Mode_AIN 模拟输入</p><p>GPIO_Mode_IN_FLOATING 浮空输入</p><p>GPIO_Mode_IPD 下拉输入</p><p>GPIO_Mode_IPU 上拉输入</p><p>GPIO_Mode_Out_OD 开漏输出</p><p>GPIO_Mode_Out_PP 推挽输出</p><p>GPIO_Mode_AF_OD 复用开漏输出</p><p>GPIO_Mode_AF_PP 复用推挽输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init);           #初始IO口状态      </span><br><span class="line"></span><br><span class="line">HAL_GPIO_DeInit(GPIO_TypeDef *GPIOx, uint32_t GPIO_Pin);                   #重置IO口状态 </span><br><span class="line"></span><br><span class="line">HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);                  #读取IO口状态 </span><br><span class="line"></span><br><span class="line">HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState);  #设置IO口状态 </span><br><span class="line"></span><br><span class="line">*PinState：GPIO 端口输出的状态，可以是 GPIO_PIN_RESET 或 GPIO_PIN_SET     </span><br><span class="line"></span><br><span class="line">HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);         #转换IO口状态      </span><br><span class="line"></span><br><span class="line">HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);                   #锁定IO口状态</span><br><span class="line"></span><br><span class="line">HAL_Delay()                                                                 #()填毫秒数</span><br></pre></td></tr></table></figure><h2 id="实践led点亮-有源蜂鸣器的发音">实践led点亮/有源蜂鸣器的发音</h2><p>Cubemx对应引脚设置GPIO_Output,生成代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">while (1)</span><br><span class="line"> &#123;</span><br><span class="line">   /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">   /* USER CODE BEGIN 3 */</span><br><span class="line"></span><br><span class="line">     HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState);  #填入你的IO口及对应状态</span><br><span class="line">     HAL_Delay(500);</span><br><span class="line">     HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState);  #填入你的IO口及对应相反状态</span><br><span class="line">     HAL_Delay(500);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>或者，你可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while (1)</span><br><span class="line"> &#123;</span><br><span class="line">   /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">   /* USER CODE BEGIN 3 */</span><br><span class="line"></span><br><span class="line">    HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);           #填入你的IO口及对应状态</span><br><span class="line">     HAL_Delay(500);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>则可以实现led的闪烁和蜂鸣器的发音。</p><h2 id="摁键的控制-光敏传感器的传感">摁键的控制/光敏传感器的传感</h2><p>Cubemx对应引脚设置GPIO_INput,生成代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">while (1)</span><br><span class="line"> &#123;</span><br><span class="line">   /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">   /* USER CODE BEGIN 3 */</span><br><span class="line">   </span><br><span class="line">    HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);           #填入你的IO口</span><br><span class="line">    </span><br><span class="line">    if(HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)==GPIO_PIN_RESET)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">       HAL_Delay(10);   #延时消抖     </span><br><span class="line">       </span><br><span class="line">         if(HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)==GPIO_PIN_RESET)  #简单的摁键消抖</span><br><span class="line">          &#123;</span><br><span class="line">            #摁键/光敏传感器所控制的模块</span><br><span class="line">          &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">光敏模块引脚说明</span><br><span class="line"></span><br><span class="line">VCC：电源引脚，接单片机+5V或者3.3V。</span><br><span class="line">GND：地线，接单片机GND。</span><br><span class="line">DO：开关量输出（0或1），模块在无光条件下或光强达不到设定阈值时，DO口输出高电平；当外界环境光强超过设定阈值时，DO输出低电平。</span><br><span class="line">AO：模拟量输出（电压），与单片机AD模块相连，通过AD转换，获得准确数值。（后续中使用PA1引脚作为ADC转换，因此此处接单片机的PA1引脚）</span><br></pre></td></tr></table></figure><p>故只能实现光信号简单的控制。</p><h2 id="主要参考资源">主要参考资源</h2><p>1.<a href="https://www.bilibili.com/video/BV1th411z7sn?p=8&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">B站江科大stm32  P5-8</a></p><p>2.<a href="https://www.bilibili.com/video/BV1mU421o7vt/?spm_id_from=333.337.search-card.all.click&amp;vd_source=d8d57f27fe1616d3699698e41773e81c">B站keysking</a></p><p>3.<a href="https://www.bilibili.com/video/BV1344y167qm?spm_id_from=333.880.my_history.page.click">B站爱上半导体</a></p><p>4.<a href="https://www.bilibili.com/video/BV1bt4y177E8?spm_id_from=333.880.my_history.page.click">维库电子市场网</a></p><p>5.<a href="https://blog.csdn.net/weixin_58632615/article/details/124729997?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=stm32hal%E5%BA%93%E5%85%89%E6%95%8F&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduweb~default-6-124729997.nonecase&amp;spm=1018.2226.3001.4450">CSDN xiang–ying</a></p><p>6.<a href="https://blog.csdn.net/qq_41968464/article/details/126856223?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171240583816800222891676%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171240583816800222891676&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-126856223-null-null.142%5Ev100%5Epc_search_result_base4&amp;utm_term=stm32hal%E5%BA%93%E5%85%89%E6%95%8F&amp;spm=1018.2226.3001.4187">CSDN 编号09527</a></p><p>7.stm32官方固件参考手册 、stm32中文参考手册</p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32学习（一）序言</title>
      <link href="/2024/04/05/stm32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%BA%8F%E8%A8%80/"/>
      <url>/2024/04/05/stm32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%BA%8F%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="学习stm32的初衷"><a href="#学习stm32的初衷" class="headerlink" title="学习stm32的初衷"></a>学习stm32的初衷</h2><p>由于我参加了足基的春招，铩羽而归，发现之前所学不成体系，故以写博客的方式来梳理知识，希望可以在stm32上有些许收获。</p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
